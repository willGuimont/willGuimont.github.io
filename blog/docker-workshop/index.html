<!doctype html><html data-theme=dark lang=en xmlns=http://www.w3.org/1999/xhtml><head><meta charset=UTF-8><meta content="William Guimont-Martin's personal website" name=description><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#0066ff name=theme-color><meta content=#66ccff media=(prefers-color-scheme:dark) name=theme-color><meta content="default-src 'none';font-src 'self';img-src 'self' https: data:;media-src 'self' https:;style-src 'self' 'unsafe-inline';frame-src https://player.vimeo.com https://www.youtube-nocookie.com https://toot.community;base-uri 'none';form-action 'none';connect-src 'self' https://mastodon.social https://toot.community;script-src 'self' 'self'" http-equiv=content-security-policy><title>Docker Workshop - wigum::website</title><link href=https://willguimont.com/blog/docker-workshop/ rel=canonical><link href=https://mastodon.social/@willGuimont rel=me><meta content=@willGuimont@mastodon.social name=fediverse:creator><link href=https://willguimont.com/favicon.png rel=icon type=image/png><link href=https://willguimont.com/apple-touch-icon.png rel=apple-touch-icon sizes=180x180 type=image/png><link title="wigum::website - RSS Feed" href=https://willguimont.com/rss.xml rel=alternate type=application/rss+xml><link title="wigum::website - Atom Feed" href=https://willguimont.com/atom.xml rel=alternate type=application/atom+xml><style>:root{--accent-color:#06f}[data-theme=dark]{--accent-color:#6cf}@media (prefers-color-scheme:dark){:root:not([data-theme=light]){--accent-color:#6cf}}</style><link href=https://willguimont.com/style.css rel=stylesheet><link href=https://willguimont.com/icons.css rel=stylesheet><link href=https://willguimont.com/custom.css rel=stylesheet><link media="(prefers-color-scheme: light)" href=https://willguimont.com/syntax-theme-light.css rel=stylesheet><link media="(prefers-color-scheme: dark)" href=https://willguimont.com/syntax-theme-dark.css rel=stylesheet><script defer src=https://willguimont.com/closable.js></script><script defer src=https://willguimont.com/copy-button.js></script><script defer src=https://willguimont.com/fuse.js></script><script defer src=https://willguimont.com/search-fuse.js></script><script defer src=https://willguimont.com/theme-switcher.js></script><meta content=wigum::website property=og:site_name><meta content="Docker Workshop - wigum::website" property=og:title><meta content=https://willguimont.com/blog/docker-workshop/ property=og:url><meta content="Learn the basics of Docker with this hands-on workshop" property=og:description><meta content=en_US property=og:locale><body><header id=site-nav><nav><a href=#main-content tabindex=0> Skip to Main Content </a><ul><li id=home><a href=https://willguimont.com> <i class=icon></i>wigum::website</a><li class=divider><li><a href=https://willguimont.com/blog/>Blog</a><li><details class=closable><summary>Links</summary> <ul><li><a class=external href=https://github.com/willGuimont target=_blank>GitHub</a><li><a class=external href=https://www.youtube.com/@willGuimont target=_blank>YouTube</a><li><a class=external href=https://www.linkedin.com/in/william-guimont-martin/ target=_blank>LinkedIn</a><li><a class=external href=https://www.thingiverse.com/wigum/designs target=_blank>Thingiverse</a><li><a class=external href=https://cults3d.com/en/users/wigum/ target=_blank>Cults3D</a><li><a class=external href=https://www.instagram.com/wilguimont/ target=_blank>Instagram</a><li><a href="https://scholar.google.com/citations?user=sZIyj3IAAAAJ&hl=en" class=external target=_blank>Google Scholar</a><li><a class=external href=https://www.researchgate.net/profile/William-Guimont-Martin target=_blank>ResearchGate</a><li><a class=external href=https://mastodon.social/@willGuimont target=_blank>Mastodon</a><li><a class=external href=https://ko-fi.com/wigum target=_blank>Coffee</a></ul></details><li id=tags><a class=circle href=https://willguimont.com/tags title=tags> <i class=icon></i> </a><li id=search><button class=circle id=search-toggle title=Search><i class=icon></i></button><li id=theme-switcher><details class=closable><summary class=circle title=Theme><i class=icon></i></summary> <ul><li><button title="Switch to Light Theme" class=circle id=theme-light><i class=icon></i></button><li><button title="Switch to Dark Theme" class=circle id=theme-dark><i class=icon></i></button><li><button title="Use System Theme" class=circle id=theme-system><i class=icon></i></button></ul></details><li id=feed><details class=closable><summary class=circle title=Feed><i class=icon></i></summary> <ul><li><a href=https://willguimont.com/rss.xml>RSS</a><li><a href=https://willguimont.com/atom.xml>Atom</a></ul></details><li id=repo><a class=circle href=https://github.com/willGuimont/willGuimont.github.io title=Repository> <i class=icon></i> </a></ul></nav><div id=search-container><label class=visually-hidden for=search-bar>Search</label><input placeholder="Search for…" autocomplete=off disabled id=search-bar type=search><div id=search-results-container><div id=search-results></div></div></div></header><main id=main-content><article><div id=heading><p><small> <time datetime=" 2025-09-07T00:00:00+00:00">Published on September 07, 2025</time></small><h1>Docker Workshop</h1><p><small><span>By William Guimont-Martin</span><span> • </span><span>16 minutes read</span><span> • </span></small><ul class=tags><a class=tag href=https://willguimont.com/tags>tags:</a><li><a class=tag href=https://willguimont.com/tags/computer-sciences/>Computer Sciences</a><li><a class=tag href=https://willguimont.com/tags/docker/>Docker</a><li><a class=tag href=https://willguimont.com/tags/workshop/>Workshop</a><li><a class=tag href=https://willguimont.com/tags/software-engineering/>Software Engineering</a></ul><br></div><div id=buttons-container><details class=closable id=toc><summary title="Table of Contents"><i class=icon></i></summary> <div><strong class=title>Table of Contents</strong><div><ol><li><a href=https://willguimont.com/blog/docker-workshop/#setup>Setup</a><ol><li><a href=https://willguimont.com/blog/docker-workshop/#instructions>Instructions</a><li><a href=https://willguimont.com/blog/docker-workshop/#solutions>Solutions</a></ol><li><a href=https://willguimont.com/blog/docker-workshop/#docker>Docker</a><ol><li><a href=https://willguimont.com/blog/docker-workshop/#why-containerization>Why containerization?</a><li><a href=https://willguimont.com/blog/docker-workshop/#what-is-containerization>What is containerization?</a></ol><li><a href=https://willguimont.com/blog/docker-workshop/#containers-manually>Containers manually</a><li><a href=https://willguimont.com/blog/docker-workshop/#docker-basics>Docker basics</a><ol><li><a href=https://willguimont.com/blog/docker-workshop/#exercise-01-running-a-prebuilt-image>Exercise 01 – Running a prebuilt image</a><li><a href=https://willguimont.com/blog/docker-workshop/#exercise-02-container-management>Exercise 02 – Container management</a><li><a href=https://willguimont.com/blog/docker-workshop/#exercise-03-postgresql-database>Exercise 03 – PostgreSQL database</a></ol><li><a href=https://willguimont.com/blog/docker-workshop/#dockerfile>Dockerfile</a><ol><li><a href=https://willguimont.com/blog/docker-workshop/#exercise-04-haskell-service-dockerfile>Exercise 04 – Haskell service Dockerfile</a><li><a href=https://willguimont.com/blog/docker-workshop/#exercise-05-python-application-dockerfile>Exercise 05 – Python application Dockerfile</a></ol><li><a href=https://willguimont.com/blog/docker-workshop/#advanced-docker>Advanced Docker</a><ol><li><a href=https://willguimont.com/blog/docker-workshop/#multi-stage-image-builds>Multi-stage image builds</a><li><a href=https://willguimont.com/blog/docker-workshop/#exercise-06-rust-multi-stage-build>Exercise 06 – Rust multi-stage build</a><li><a href=https://willguimont.com/blog/docker-workshop/#volumes>Volumes</a></ol><li><a href=https://willguimont.com/blog/docker-workshop/#extras>Extras</a><ol><li><a href=https://willguimont.com/blog/docker-workshop/#cleanup>Cleanup</a><li><a href=https://willguimont.com/blog/docker-workshop/#docker-compose>Docker Compose</a><li><a href=https://willguimont.com/blog/docker-workshop/#podman>Podman</a><li><a href=https://willguimont.com/blog/docker-workshop/#kubernetes>Kubernetes</a></ol></ol></div></div></details><a title="Go to Top" href=#top id=go-to-top><i class=icon></i></a><a href="https://shareopenly.org/share/?url=https://willguimont.com/blog/docker-workshop/&text=Learn%20the%20basics%20of%20Docker%20with%20this%20hands-on%20workshop" id=share title=Share><i class=icon></i></a><a title="File an Issue" href=https://github.com/willGuimont/willGuimont.github.io/issues id=issue><i class=icon></i></a></div><h2>Table of Contents</h2><ol><li><a href=https://willguimont.com/blog/docker-workshop/#setup>Setup</a><ol><li><a href=https://willguimont.com/blog/docker-workshop/#instructions>Instructions</a><li><a href=https://willguimont.com/blog/docker-workshop/#solutions>Solutions</a></ol><li><a href=https://willguimont.com/blog/docker-workshop/#docker>Docker</a><ol><li><a href=https://willguimont.com/blog/docker-workshop/#why-containerization>Why containerization?</a><li><a href=https://willguimont.com/blog/docker-workshop/#what-is-containerization>What is containerization?</a></ol><li><a href=https://willguimont.com/blog/docker-workshop/#containers-manually>Containers manually</a><li><a href=https://willguimont.com/blog/docker-workshop/#docker-basics>Docker basics</a><ol><li><a href=https://willguimont.com/blog/docker-workshop/#exercise-01-running-a-prebuilt-image>Exercise 01 – Running a prebuilt image</a><li><a href=https://willguimont.com/blog/docker-workshop/#exercise-02-container-management>Exercise 02 – Container management</a><li><a href=https://willguimont.com/blog/docker-workshop/#exercise-03-postgresql-database>Exercise 03 – PostgreSQL database</a></ol><li><a href=https://willguimont.com/blog/docker-workshop/#dockerfile>Dockerfile</a><ol><li><a href=https://willguimont.com/blog/docker-workshop/#exercise-04-haskell-service-dockerfile>Exercise 04 – Haskell service Dockerfile</a><li><a href=https://willguimont.com/blog/docker-workshop/#exercise-05-python-application-dockerfile>Exercise 05 – Python application Dockerfile</a></ol><li><a href=https://willguimont.com/blog/docker-workshop/#advanced-docker>Advanced Docker</a><ol><li><a href=https://willguimont.com/blog/docker-workshop/#multi-stage-image-builds>Multi-stage image builds</a><li><a href=https://willguimont.com/blog/docker-workshop/#exercise-06-rust-multi-stage-build>Exercise 06 – Rust multi-stage build</a><li><a href=https://willguimont.com/blog/docker-workshop/#volumes>Volumes</a></ol><li><a href=https://willguimont.com/blog/docker-workshop/#extras>Extras</a><ol><li><a href=https://willguimont.com/blog/docker-workshop/#cleanup>Cleanup</a><li><a href=https://willguimont.com/blog/docker-workshop/#docker-compose>Docker Compose</a><li><a href=https://willguimont.com/blog/docker-workshop/#podman>Podman</a><li><a href=https://willguimont.com/blog/docker-workshop/#kubernetes>Kubernetes</a></ol></ol><p>Docker and containerization have revolutionized the way applications are developed, deployed, and managed. Containers provide a lightweight and efficient way to package applications and their dependencies, ensuring consistency across different environments.<h2 id=setup>Setup</h2><p>The original workshop was designed to use with a virtual machine (<a href=https://github.com/willGuimont/IFT2001-Docker rel=external>willGuimont/IFT2001-Docker</a>). While you can follow the instructions below to set up the virtual machine, you can also choose to follow the workshop using Docker.<p>Follow these steps to prepare your environment.<ol><li>Install <a href=https://docs.docker.com/engine/install/ubuntu/ rel=external>Docker</a><li><code>docker run -it --rm ubuntu:latest bash</code><li>In the Docker container, run: <ol><li><code>sudo apt update && sudo apt install -y git</code><li><code>mkdir .atelier && cd .atelier && git clone https://github.com/willGuimont/IFT2001-Docker</code><li><code>cd ateliers-iftglo-2001</code><li><code>./helper/install.sh</code><li><code>python3 ./helper/prepare_bashrc.py && source ~/.bashrc</code><li>Copy the files in your home directory: <code>cd ~/.atelier/ateliers-iftglo-2001/files && cp -r . ~/</code></ol></ol><h3 id=instructions>Instructions</h3><p>The instruction above sets up your environment for the workshop. The grading commands are of the form <code>correction_nn</code>, where <code>nn</code> is an integer representing the exercise number, for example <code>correction_03</code> for exercise 3. Instructions for validating commands will be provided with the first question that has an expected result.<p>To complete this workshop, you must perform each exercise directly in the terminal. You will use the <code>nano</code> text editor to modify the requested scripts. To open a file with nano, run the following in the terminal.<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">nano</span><span class=z-string> test.sh</span></span></code></pre><p>You can then edit the file; enter<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-support z-function">echo</span><span class=z-string> '</span><span class=z-string>Hello world</span><span class=z-string>'</span></span></code></pre><p>To exit nano, press <kbd>CTRL</kbd>-<kbd>X</kbd>, then answer <code>y</code> to save the changes. Run the following commands to validate that everything works:<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">chmod</span><span class=z-string> +x</span><span class=z-string> test.sh</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">./test.sh</span></span></code></pre><p>These commands should print <code>Hello world</code>.<blockquote class=markdown-alert-tip><p><strong>Adventurers only</strong><p>If you are comfortable with the command line, we encourage you to try completing this workshop using <code>vim</code> as your text editor. A brief introduction to <code>vim</code> commands is available on <a href=https://missing.csail.mit.edu/2020/editors/ rel=external>MIT’s The Missing Semester</a>. <code>vim</code> offers many shortcuts to edit text and code very efficiently. As a programmer, you will spend a lot of time writing code, so investing in learning <code>vim</code> is worthwhile for the rest of your career. There are plugins emulating <code>vim</code> commands for most IDEs: <a href="https://marketplace.visualstudio.com/items?itemName=vscodevim.vim" rel=external>Vim for VS Code</a> or <a href=https://plugins.jetbrains.com/plugin/164-ideavim rel=external>IdeaVim for JetBrains products</a>.<p><strong>Please note that no assistance regarding <code>vim</code> will be provided during this workshop.</strong></blockquote><h3 id=solutions>Solutions</h3><p>Proposed solutions to the exercises in these workshops are available in the following GitHub repository: <a href=https://github.com/ulavalIFTGLOateliers/IFT2001-Docker rel=external>ulavalIFTGLOateliers/IFT2001-Docker</a>.<hr><h2 id=docker>Docker</h2><p>After your success with <a href=https://willguimont.com/blog/bash-workshop/>Bash</a>, your manager has given you a new mission: find a solution to the application deployment problem. Your company frequently encounters outages due to incompatibilities between different dependency versions. Indeed, each developer can choose the operating system they wish to work on. Consequently, some developers use different Linux distributions (Ubuntu, Arch, Gentoo), while others prefer Windows.<p>This situation often leads to version issues, as dependencies vary from one OS to another. And worse, the versions used differ from those deployed on the production server. The recurring excuse “It worked on my machine” when a developer causes a production outage has finally exasperated your manager. He is asking you to find a solution.<p>That’s how you discover Docker, a platform that lets you build, deploy, and run applications in lightweight, isolated containers. With Docker, you can create a specific container for each microservice, including all required libraries and dependencies. This approach ensures that each application will run consistently, regardless of library versions used by individual developers. Moreover, Docker allows you to reproduce the development environment on the production server, thereby eliminating issues stemming from environment differences.<p>With Docker, you will tackle the challenge of running your company’s three main microservices. Here are the microservices you must get working:<ol><li>a web server health monitoring application written in Haskell;<li>a document management API written in Rust, requiring a PostgreSQL database; and<li>a Python application for visualizing web server health.</ol><div class=wide-crt><div class="crt scanlines" aria-hidden=true><pre class="giallo z-code"><code data-lang=plain><span class=giallo-l><span>┌────────────────────────────── MICROSERVICES (ARCH OVERVIEW) ───────────────────────────┐</span></span>
<span class=giallo-l><span>│                                                                                        │</span></span>
<span class=giallo-l><span>│  (3) python_app (CLI)                                                                  │</span></span>
<span class=giallo-l><span>│      Image: python_app                                                                 │</span></span>
<span class=giallo-l><span>│      Mode: --network=host (workshop)                                                   │</span></span>
<span class=giallo-l><span>│      BACKEND_URL = http://localhost:8080                                               │</span></span>
<span class=giallo-l><span>│      Uses: list/add endpoints, view uptime stats                                       │</span></span>
<span class=giallo-l><span>│            │                                                                           │</span></span>
<span class=giallo-l><span>│            │ HTTP (JSON)                                                               │</span></span>
<span class=giallo-l><span>│            ▼                                                                           │</span></span>
<span class=giallo-l><span>│  (1) status-checker (Haskell)                                                          │</span></span>
<span class=giallo-l><span>│      Image: status-checker                                                             │</span></span>
<span class=giallo-l><span>│      Port: 8080                                                                        │</span></span>
<span class=giallo-l><span>│      Storage: monitoring.sqlite (SQLite)                                               │</span></span>
<span class=giallo-l><span>│            │                                                                           │</span></span>
<span class=giallo-l><span>│            │ HTTP health probe (/documents or /health)                                 │</span></span>
<span class=giallo-l><span>│            ▼                                                                           │</span></span>
<span class=giallo-l><span>│  (2) rust_api (Actix Web)                                                              │</span></span>
<span class=giallo-l><span>│      Image: rust_api (multi-stage)                                                     │</span></span>
<span class=giallo-l><span>│      Port: 8081                                                                        │</span></span>
<span class=giallo-l><span>│      Env: DATABASE_URL=postgres://postgres:postgres@db                                 │</span></span>
<span class=giallo-l><span>│            │                                                                           │</span></span>
<span class=giallo-l><span>│            │ SQL (Diesel)                                                              │</span></span>
<span class=giallo-l><span>│            ▼                                                                           │</span></span>
<span class=giallo-l><span>│      PostgreSQL                                                                        │</span></span>
<span class=giallo-l><span>│      Image: postgres                                                                   │</span></span>
<span class=giallo-l><span>│      Port: 5432                                                                        │</span></span>
<span class=giallo-l><span>│      Volume: db:/var/lib/postgresql/data                                               │</span></span>
<span class=giallo-l><span>│                                                                                        │</span></span>
<span class=giallo-l><span>│  Data Flows (top→down):                                                                │</span></span>
<span class=giallo-l><span>│    python_app ──HTTP──▶ status-checker ──HTTP──▶ rust_api ──SQL──▶ PostgreSQL          │</span></span>
<span class=giallo-l><span>│                                                                                        │</span></span>
<span class=giallo-l><span>│  Summary:                                                                              │</span></span>
<span class=giallo-l><span>│    - python_app only contacts status-checker.                                          │</span></span>
<span class=giallo-l><span>│    - status-checker pings rust_api for availability.                                   │</span></span>
<span class=giallo-l><span>│    - rust_api persists documents in Postgres.                                          │</span></span>
<span class=giallo-l><span>│                                                                                        │</span></span>
<span class=giallo-l><span>│  Ports: 8080 (status-checker) | 8081 (rust_api) | 5432 (Postgres)                      │</span></span>
<span class=giallo-l><span>└────────────────────────────────────────────────────────────────────────────────────────┘</span></span></code></pre></div></div><h3 id=why-containerization>Why containerization?</h3><p><strong>Isolation</strong><br> One of the main advantages of containerization is isolation. It often happens that different applications require specific dependency versions. With Docker, you can install different dependency versions in distinct containers, without risking conflicts or compromising other applications. Furthermore, if you need to run applications on different operating systems, such as Ubuntu and Arch Linux, you can simply wrap them in Docker containers, avoiding the need to rewrite applications for each system.<p><strong>Portability</strong><br> Portability is another key advantage of Docker. Once you have set up a development environment with all required dependencies, reproducing that configuration on other machines or for new team members becomes tedious. Thanks to Docker, you can create an image that contains all required dependencies and configuration, which can be easily distributed and run on different platforms, whether Linux, Windows, or others. This enables a new team member to start quickly without spending weeks configuring their environment. It’s also an advantage when deploying applications to a server.<p><strong>Reproducibility</strong><br> Reproducibility is also simplified with Docker. Docker images are versioned, which means it is easy to reproduce builds identically, ensuring that development, test, and production environments are consistent. You just need to specify the version of the Docker image used to guarantee consistency and avoid issues related to variations across environments.<p><strong>Efficiency</strong><br> In terms of efficiency, Docker offers a significant advantage over virtual machines (VMs). Unlike VMs, Docker does not need to run a full operating system for each container, which greatly reduces resource consumption. Docker containers share the host kernel, making them lightweight and quick to start.<p><strong>Community</strong><br> Docker’s surrounding community is very active and offers a multitude of preconfigured images for various popular tools and technologies such as Node.js, Python, and many others. These preconfigured images facilitate deployment and usage of these technologies, saving developers time by avoiding manual environment setup.<p><strong>Industry</strong><br> Finally, it’s important to emphasize that Docker has become a de facto standard in the software development industry. Many companies use Docker for development, testing, and deployment of their applications. Docker is now an essential tool for software developers.<h3 id=what-is-containerization>What is containerization?</h3><p>Docker is an open-source software platform that lets you create, deploy, and run applications in lightweight, isolated containers. A Docker container is a runtime unit that encapsulates an application together with all of its necessary elements, such as libraries, dependencies, and configuration files. These containers are self-contained and portable, meaning they can run consistently across different systems, whether a development, test, or production environment.<p>Docker is similar to a virtual machine that isolates an application from the host system. However, Docker is much more efficient than a VM, which requires a full operating system for each instance. Docker instead shares the host operating system’s <code>kernel</code>, saving resources and making containers faster to start and run.<p>Here is some Docker terminology. You do not have to read the advanced sections to complete this workshop. As a supplement, you can watch the video <a href="https://www.youtube.com/watch?v=J0NuOlA2xDc" rel=external>“Never install locally”</a>.<p><strong>Docker Image</strong><br> A Docker image is a template or build blueprint that contains all the elements needed to run an application. It includes the operating system, libraries, dependencies, the application’s source code, and configuration files. Docker images are created from files called <code>Dockerfile</code> that specify the steps to build the image.<p><strong>Dockerfile</strong><br> A Dockerfile is a text file that contains the instructions to build a Docker image. It specifies the image layers, dependencies to install, files to include, and commands to run during image construction.<p><strong>Docker Container</strong><br> A Docker container is a running instance of a Docker image. It is an isolated environment that runs the application with its dependencies. Containers are lightweight, portable, and self-contained, which makes them easy to deploy across different machines.<p><strong>Docker Registry</strong><br> A Docker registry is a centralized repository that stores and manages Docker images. The default public registry is <a href=https://hub.docker.com/ rel=external>Docker Hub</a>, where you can find many ready-to-use images. You can also create and use your own private registry to store your own images.<p><strong>Union filesystem (advanced concepts)</strong><br> The <em>Union Filesystem</em>, also known as <em>UnionFS</em> or <em>OverlayFS</em>, is a technology used by Docker to manage images and container layers efficiently. The <em>Union Filesystem</em> allows you to overlay multiple file systems into a single logical view without physically merging them. This means Docker images and containers can share and reuse common file layers, saving storage space. It also speeds up image builds by caching layers already built. When a container starts, a new read-write layer is added on top of the image layers, enabling container-specific changes without affecting others.<p><strong>cgroups (advanced concepts)</strong><br> <code>cgroups</code>, or <em>control groups</em>, are a Linux kernel feature used by Docker to limit and manage system resources used by containers. <code>cgroups</code> allow control of resources such as CPU, memory, disk bandwidth, and network, ensuring balanced and fair resource usage among containers. Docker uses <code>cgroups</code> to set limits and quotas on resources allocated to each container, ensuring isolation and predictable performance.<p><strong>Namespaces (advanced concepts)</strong><br> Namespaces are a Linux kernel feature that isolates system resources among processes. Docker uses several types of namespaces to provide isolation between containers, including the PID namespace (process isolation), the network namespace (network isolation), the user namespace (user isolation), and the mount namespace (mount point isolation). These namespaces ensure that each container has its own isolated view of the system, preventing processes in one container from interfering with others or with the host system.<p><strong>Chroot jail (advanced concepts)</strong><br> Chroot, or change root, is a Unix/Linux feature that changes a process’s root directory and limits its access to the file system. Docker uses chroot to create an isolated environment inside the container, where the container’s root directory becomes the starting point for all file paths. This limits the container’s access to files and directories outside its isolated environment, thereby strengthening security and isolation.<h2 id=containers-manually>Containers manually</h2><p>To clearly illustrate what Docker does, we will manually build a simplified container without using Docker. This section is inspired by <a href=https://github.com/p8952/bocker rel=external>p8952/bocker: Docker implemented in around 100 lines of bash</a>. In a terminal, enter the following commands:<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Verify that neofetch is not installed</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> The following command should raise an error; do not install the package</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">neofetch</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Folder for containers</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">mkdir</span><span class=z-string> ~/containers</span><span>;</span><span class="z-support z-function"> cd</span><span class=z-string> ~/containers</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Build the container's filesystem</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">sudo</span><span class=z-string> apt</span><span class=z-string> update</span><span>;</span><span class="z-entity z-name z-function"> sudo</span><span class=z-string> apt</span><span class=z-string> install</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">y</span><span class=z-string> debootstrap</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">sudo</span><span class=z-string> debootstrap</span><span class=z-string> jammy</span><span class=z-string> ./ubuntu-container</span><span class=z-string> http://archive.ubuntu.com/ubuntu/</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Create an isolated environment (namespace)</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">sudo</span><span class=z-string> unshare</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-uts</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-pid</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-mount</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-ipc</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-fork</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Mount process, system, device, and temp folders</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">mount</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">t</span><span class=z-string> proc</span><span class=z-string> none</span><span class=z-string> ./ubuntu-container/proc/</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">mount</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">t</span><span class=z-string> sysfs</span><span class=z-string> none</span><span class=z-string> ./ubuntu-container/sys</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">mount</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">o</span><span class=z-string> bind</span><span class=z-string> /dev</span><span class=z-string> ./ubuntu-container/dev</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">mount</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">o</span><span class=z-string> bind</span><span class=z-string> /tmp</span><span class=z-string> ./ubuntu-container/tmp/</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">cp</span><span class=z-string> /etc/apt/sources.list</span><span class=z-string> ./ubuntu-container/etc/apt/sources.list</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Use chroot to launch a shell in the container</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">chroot</span><span class=z-string> ./ubuntu-container/</span><span class=z-string> /bin/bash</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> and there you go, you're in an isolated container</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Install neofetch</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">apt</span><span class=z-string> update</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">apt</span><span class=z-string> install</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">y</span><span class=z-string> neofetch</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Test neofetch; the command works!</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">neofetch</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> You can run commands in the container here.</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Exit the container</span></span>
<span class=giallo-l><span class="z-support z-function">exit</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Exit unshare</span></span>
<span class=giallo-l><span class="z-support z-function">exit</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> If we try neofetch again, the command is not found.</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> We have indeed isolated the container!</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">neofetch</span></span></code></pre><p>As you can see, there is no magic in containers. We use basic Linux tools to isolate a process in its own filesystem.<h2 id=docker-basics>Docker basics</h2><h3 id=exercise-01-running-a-prebuilt-image>Exercise 01 – Running a prebuilt image</h3><p>Run the Docker image <code>hello-world</code>.<blockquote class=markdown-alert-note><p>To run a Docker image, use the <code>run</code> command.<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class=z-string> image-name</span></span></code></pre></blockquote><p>If the command works, you will see a message displayed.<details><summary>Solution</summary> <pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class=z-string> hello-world</span></span></code></pre></details><blockquote class=markdown-alert-note><p>To execute a command in the container, specify the command at the end of <code>run</code>. In the following examples, we pass <code>bash -c 'echo "Hello world"'</code> which interprets the string in the Bash interpreter.<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Prints 'Hello world' in an ubuntu container</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class=z-string> ubuntu</span><span class=z-string> bash</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">c</span><span class=z-string> '</span><span class=z-string>echo "Hello world"</span><span class=z-string>'</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Prints information about the host system</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">cat</span><span class=z-string> /etc/os-release</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Prints information from a container running Arch Linux</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class=z-string> archlinux</span><span class=z-string> bash</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">c</span><span class=z-string> '</span><span class=z-string>cat /etc/os-release</span><span class=z-string>'</span></span></code></pre></blockquote><blockquote class=markdown-alert-note><p>To launch an interactive command (such as a shell), use the <code>-it</code> flag. The <code>--rm</code> flag removes the container once it exits.<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">it</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-rm</span><span class=z-string> archlinux</span><span class=z-string> bash</span></span></code></pre></blockquote><h3 id=exercise-02-container-management>Exercise 02 – Container management</h3><blockquote class=markdown-alert-note><p>To see running containers: <code>docker ps</code>.<p>To stop a container: <code>docker stop container_id</code>.<p><strong>Note that the command may take some time to run.</strong></blockquote><p>Tasks:<ol><li>Launch an interactive terminal with Docker;<li>Open another terminal and inspect running containers;<li>Stop the Docker container from the second terminal.</ol><details><summary>Solution</summary> <pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class=z-comment>#</span><span class=z-comment> In the first terminal</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">it</span><span class=z-string> archlinux</span><span class=z-string> bash</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> In the second terminal</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> ps</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> stop</span><span class=z-string> id</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> or</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> rm</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">f</span><span class=z-string> id</span></span></code></pre></details><h3 id=exercise-03-postgresql-database>Exercise 03 – PostgreSQL database</h3><blockquote class=markdown-alert-note><p>To set environment variables in a container, use the <code>-e</code> flag.<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">it</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-rm</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">e</span><span class=z-string> HELLO=hello</span><span class=z-string> archlinux</span><span class=z-string> sh</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">c</span><span class=z-string> '</span><span class=z-string>echo $HELLO</span><span class=z-string>'</span></span></code></pre></blockquote><blockquote class=markdown-alert-note><p>To open a network port, use the <code>-p docker:host</code> flag, where <code>docker</code> is the port number inside the container and <code>host</code> is the port number on the host.<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">p</span><span class=z-string> 127.0.0.1:8080:80</span><span class=z-string> nginx</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> You can access the port via the URL http://localhost:8080/</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">curl</span><span class=z-string> http://localhost:8080/</span></span></code></pre></blockquote><p>Launch a PostgreSQL database with Docker.<p>Requirements:<ul><li>Image name: <code>postgres</code><li>Set the environment variable <code>POSTGRES_PASSWORD=postgres</code><li>Map Docker port 5432 to host port 5432<li>Leave this container running.</ul><details><summary>Solution</summary> <pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">e</span><span class=z-string> POSTGRES_PASSWORD=postgres</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">p</span><span class=z-string> 5432:5432</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-rm</span><span class=z-string> postgres</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> or</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-name</span><span class=z-string> postgres</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">e</span><span class=z-string> POSTGRES_PASSWORD=postgres</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">p</span><span class=z-string> 5432:5432</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-rm</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">d</span><span class=z-string> postgres</span></span></code></pre></details><h2 id=dockerfile>Dockerfile</h2><p>Dockerfiles are configuration files used to create custom Docker images. They allow you to define, reproducibly and automatically, an application’s runtime environment inside a Docker container.<p>A Dockerfile contains a series of instructions that specify the steps needed to build a Docker image. These instructions include actions such as selecting the base image, installing dependencies, configuring environment variables, copying files, running commands, and more.<p>Here is an annotated example Dockerfile for a Python application.<pre class="giallo z-code"><code data-lang=docker><span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Use the Python 3.9 slim base image</span></span>
<span class=giallo-l><span class=z-keyword>FROM</span><span> python:3.9-slim</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Set the working directory inside the container</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Specifies the directory for RUN, CMD, ENTRYPOINT, COPY, and ADD</span></span>
<span class=giallo-l><span class=z-keyword>WORKDIR</span><span> /app</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Copy requirements.txt from the host into the Docker container</span></span>
<span class=giallo-l><span class=z-keyword>COPY</span><span> requirements.txt .</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Run a Bash command to install Python dependencies</span></span>
<span class=giallo-l><span class=z-keyword>RUN</span><span> pip install -r requirements.txt</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Copy the source code into the Docker container</span></span>
<span class=giallo-l><span class=z-keyword>COPY</span><span> . .</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Set the default command when the container starts</span></span>
<span class=giallo-l><span class=z-keyword>CMD</span><span> [</span><span class=z-string>"</span><span class=z-string>python</span><span class=z-string>"</span><span>, </span><span class=z-string>"</span><span class=z-string>app.py</span><span class=z-string>"</span><span>]</span></span></code></pre><p>To build the image, use <code>docker build -t &lt;tag> .</code>. The <code>-t &lt;tag></code> argument gives the image the name <code>&lt;tag></code>. For the previous application, you could use <code>docker build -t python-app .</code>. Note that the order of instructions matters.<p>It is crucial to define the order of operations in a Dockerfile due to how Docker builds images. Each instruction in the Dockerfile creates a new layer in the Docker image, and the order can significantly impact build efficiency and performance.<p>Docker uses a cache to speed up image builds. When you run an instruction, Docker checks whether that instruction has already been executed in a previous layer. If so and the parameters are identical, Docker reuses the cached layer instead of rebuilding it. This saves build time. However, if you modify an instruction higher up in the Dockerfile, all subsequent instructions will have their cache invalidated and must be rebuilt. <strong>For example, if you perform resource-intensive operations such as compiling code that changes whenever you modify the source, it can be preferable to place those steps towards the end of the Dockerfile to benefit from caching as much as possible.</strong><h3 id=exercise-04-haskell-service-dockerfile>Exercise 04 – Haskell service Dockerfile</h3><p>Use the <code>README.md</code> in the folder <code>~/Applications/status-checker</code> to write a Dockerfile that runs the Haskell application.<p>Requirements:<ul><li>Base image <code>haskell:9.0-buster</code><li>Run <code>stack setup --install-ghc</code><li>Workdir <code>/app</code><li>Copy the source code into <code>/app</code><li>Run <code>stack build</code><li>Launch the server with <code>stack run</code></ul><p>Then, start the container exposing port 8080. If everything works, you should be able to run:<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">curl</span><span class=z-string> http://localhost:8080/endpoints</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Expected response</span></span>
<span class=giallo-l><span>{</span><span>}</span><span>%</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Or</span></span>
<span class=giallo-l><span>{</span><span>}</span></span></code></pre><p>Leave this container running.<details><summary>Solution</summary> <p>Dockerfile:</p> <pre class="giallo z-code"><code data-lang=docker><span class=giallo-l><span class=z-keyword>FROM</span><span> haskell:9.0-buster</span></span>
<span class=giallo-l><span class=z-keyword>RUN</span><span> stack setup --install-ghc</span></span>
<span class=giallo-l><span class=z-keyword>WORKDIR</span><span> /app</span></span>
<span class=giallo-l><span class=z-keyword>COPY</span><span> . .</span></span>
<span class=giallo-l><span class=z-keyword>RUN</span><span> stack build</span></span>
<span class=giallo-l><span class=z-keyword>CMD</span><span> [</span><span class=z-string>"</span><span class=z-string>stack</span><span class=z-string>"</span><span>, </span><span class=z-string>"</span><span class=z-string>run</span><span class=z-string>"</span><span>]</span></span></code></pre> <p>Execution:</p> <pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> build</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">t</span><span class=z-string> status-checker</span><span class=z-string> .</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-rm</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">p</span><span class=z-string> 8080:8080</span><span class=z-string> status-checker</span></span></code></pre></details><h3 id=exercise-05-python-application-dockerfile>Exercise 05 – Python application Dockerfile</h3><p>Use the <code>README.md</code> in the folder <code>~/Applications/python_app</code> to write a Dockerfile that runs the Python application.<p>Then, launch the application interactively and with the correct network mode.<blockquote class=markdown-alert-note><p>This application will need to access your computer’s local network to make requests to the container from the previous exercise; to do so, pass the argument <code>--network="host"</code> when you run the container.</blockquote><p>If everything works, you should be able to use the application to add URLs to monitor and see the results.<details><summary>Solution</summary> <p>Dockerfile:</p> <pre class="giallo z-code"><code data-lang=docker><span class=giallo-l><span class=z-keyword>FROM</span><span> python:3.9-slim</span></span>
<span class=giallo-l><span class=z-keyword>WORKDIR</span><span> /app</span></span>
<span class=giallo-l><span class=z-keyword>COPY</span><span> requirements.txt .</span></span>
<span class=giallo-l><span class=z-keyword>RUN</span><span> pip install -r requirements.txt</span></span>
<span class=giallo-l><span class=z-keyword>COPY</span><span> . .</span></span>
<span class=giallo-l><span class=z-keyword>CMD</span><span> [</span><span class=z-string>"</span><span class=z-string>python</span><span class=z-string>"</span><span>, </span><span class=z-string>"</span><span class=z-string>main.py</span><span class=z-string>"</span><span>]</span></span></code></pre> <p>Execution:</p> <pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> build</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">t</span><span class=z-string> python_app</span><span class=z-string> .</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-rm</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">it</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-network=</span><span class=z-string>"</span><span class=z-string>host</span><span class=z-string>"</span><span class=z-string> python_app</span></span></code></pre></details><h2 id=advanced-docker>Advanced Docker</h2><p>Sometimes, you may need to create more complex Docker images. Here, we will explore two advanced Docker features: multi-stage builds and volumes.<h3 id=multi-stage-image-builds>Multi-stage image builds</h3><p>Multi-stage builds are an advanced Docker feature that enables optimized image creation using several distinct stages in the build process. This separates build and production stages, often resulting in final images that are lighter and more secure by minimizing what remains in the final image.<p>For example, for a JavaScript React application, we can split the build into two stages.<p>Create the application:<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">npx</span><span class=z-string> create-react-app</span><span class=z-string> my-app</span></span></code></pre><p>Dockerfile:<pre class="giallo z-code"><code data-lang=docker><span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Stage 1: Build the application</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Use `as build` to name this build stage</span></span>
<span class=giallo-l><span class=z-keyword>FROM</span><span> node:14-alpine </span><span class=z-keyword>as</span><span> build</span></span>
<span class=giallo-l><span class=z-keyword>WORKDIR</span><span> /app</span></span>
<span class=giallo-l><span class=z-keyword>COPY</span><span> package*.json ./</span></span>
<span class=giallo-l><span class=z-keyword>RUN</span><span> npm install</span></span>
<span class=giallo-l><span class=z-keyword>COPY</span><span> . .</span></span>
<span class=giallo-l><span class=z-keyword>RUN</span><span> npm run build</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Stage 2: Prepare the server</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Here, we start a new image from scratch</span></span>
<span class=giallo-l><span class=z-keyword>FROM</span><span> nginx:alpine</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Copy the compiled app from the previous stage</span></span>
<span class=giallo-l><span class=z-keyword>COPY</span><span> --from=build /app/build /usr/share/nginx/html</span></span>
<span class=giallo-l><span class=z-keyword>EXPOSE</span><span> 80</span></span>
<span class=giallo-l><span class=z-keyword>CMD</span><span> [</span><span class=z-string>"</span><span class=z-string>nginx</span><span class=z-string>"</span><span>, </span><span class=z-string>"</span><span class=z-string>-g</span><span class=z-string>"</span><span>, </span><span class=z-string>"</span><span class=z-string>daemon off;</span><span class=z-string>"</span><span>]</span></span></code></pre><p>To run:<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> build</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">t</span><span class=z-string> web-app</span><span class=z-string> .</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-rm</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">p</span><span class=z-string> 80:80</span><span class=z-string> web-app</span></span></code></pre><h3 id=exercise-06-rust-multi-stage-build>Exercise 06 – Rust multi-stage build</h3><p>Use the <code>README.md</code> in the folder <code>~/Applications/rust_api</code> to write a Dockerfile that runs the application.<p>Requirements:<ul><li>Launch the PostgreSQL database from a previous exercise;<li>Create a first stage to compile the Rust code;<li>Create a second stage to run the code; <ul><li>Start this image from <code>debian:bullseye-slim</code>;<li>Install the package <code>libpq-dev</code> with <code>apt update; apt install -y libpq-dev</code>;<li>Set the environment variable <code>DATABASE_URL=postgres://postgres:postgres@localhost</code><li>Copy <code>/app/target/release/rust_api</code> from the previous stage;</ul><li>Run the container with <code>--network="host"</code> and expose the correct port;<li>Test that everything works with <code>curl http://localhost:8081/documents</code>.</ul><details><summary>Solution</summary> <pre class="giallo z-code"><code data-lang=docker><span class=giallo-l><span class=z-keyword>FROM</span><span> rust:latest </span><span class=z-keyword>AS</span><span> build</span></span>
<span class=giallo-l><span class=z-keyword>WORKDIR</span><span> /app</span></span>
<span class=giallo-l><span class=z-keyword>COPY</span><span> . .</span></span>
<span class=giallo-l><span class=z-keyword>RUN</span><span> cargo build --release</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>FROM</span><span> debian:bullseye-slim</span></span>
<span class=giallo-l><span class=z-keyword>RUN</span><span> apt update; apt install -y libpq-dev</span></span>
<span class=giallo-l><span class=z-keyword>WORKDIR</span><span> /app</span></span>
<span class=giallo-l><span class=z-keyword>COPY</span><span> --from=build /app/target/release/rust_api ./rust_api</span></span>
<span class=giallo-l><span class=z-keyword>ENV</span><span> DATABASE_URL=postgres://postgres:postgres@db</span></span>
<span class=giallo-l><span class=z-keyword>CMD</span><span> ./rust_api</span></span></code></pre> <p>Execution</p> <pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">e</span><span class=z-string> POSTGRES_PASSWORD=postgres</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">p</span><span class=z-string> 5432:5432</span><span class=z-string> postgres</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> build</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">t</span><span class=z-string> rust_api</span><span class=z-string> .</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-rm</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-network=</span><span class=z-string>"</span><span class=z-string>host</span><span class=z-string>"</span><span class=z-string> rust_api</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Validate that the server works</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">curl</span><span class=z-string> http://localhost:8081/documents</span></span></code></pre></details><h3 id=volumes>Volumes</h3><p>In Docker, volumes are used to allow containers to access, share, and persist data between the host system and the container itself. Docker volumes store data outside the lifecycle of containers. This means that even if you destroy or recreate a container, the data stored in the volume remains intact. This separates data persistence from the container environment, providing better data management. Volumes are also useful to grant containers access to datasets too large to copy into the image, such as a training dataset for a machine learning system.<p>For example, to store PostgreSQL database data in a host folder, specify the <code>PGDATA</code> variable and mount a volume:<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">e</span><span class=z-string> POSTGRES_PASSWORD=postgres</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">p</span><span class=z-string> 5432:5432</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-rm</span><span class="z-constant z-character"> \</span></span>
<span class=giallo-l><span class="z-constant z-other">    -</span><span class="z-constant z-other">e</span><span class=z-string> PGDATA=/var/lib/postgresql/data/pgdata</span><span class="z-constant z-character"> \</span></span>
<span class=giallo-l><span class="z-constant z-other">    -</span><span class="z-constant z-other">v</span><span class=z-string> custom/mount/path:/var/lib/postgresql/data</span><span class="z-constant z-character"> \</span></span>
<span class=giallo-l><span class=z-string>    postgres</span></span></code></pre><p>To avoid rebuilding the Docker image after each change to the source code—and thus speed up development—you can make the project’s source code accessible via a volume. Thus, a <code>DockerfileDev</code> for the Python application could look like this:<pre class="giallo z-code"><code data-lang=docker><span class=giallo-l><span class=z-keyword>FROM</span><span> python:3.9-slim</span></span>
<span class=giallo-l><span class=z-keyword>WORKDIR</span><span> /app</span></span>
<span class=giallo-l><span class=z-keyword>COPY</span><span> requirements.txt .</span></span>
<span class=giallo-l><span class=z-keyword>RUN</span><span> pip install -r requirements.txt</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> We removed the line COPY . .</span></span>
<span class=giallo-l><span class=z-keyword>CMD</span><span> [</span><span class=z-string>"</span><span class=z-string>bash</span><span class=z-string>"</span><span>]</span></span></code></pre><p>Run with:<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> build</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">t</span><span class=z-string> python_app</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">f</span><span class=z-string> DockerfileDev</span><span class=z-string> .</span><span> </span></span>
<span class=giallo-l><span class="z-entity z-name z-function">docker</span><span class=z-string> run</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-rm</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">v</span><span class=z-string> .:/app</span><span class=z-string> my-app</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> In the container</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">python</span><span class=z-string> main.py</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Modify the source code</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">python</span><span class=z-string> main.py</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Changes are reflected in the container</span></span></code></pre><p>Thus, you can reuse the same image even if the source code has changed.<h2 id=extras>Extras</h2><p>Some additional Docker features and tools that may be useful in your projects.<h3 id=cleanup>Cleanup</h3><p>When using Docker, it is important to consider the storage used by images, containers, volumes, and other Docker artifacts. Poor storage management can lead to excessive disk usage and make Docker maintenance and resource management difficult. Docker provides several <code>prune</code> commands to remove unused containers and images. To clean up various Docker artifacts, the command <code>docker system prune -a -f</code> removes all unused resources.<h3 id=docker-compose>Docker Compose</h3><p>Docker Compose is a tool that allows you to easily define and manage multi-container applications. It simplifies deployment and orchestration of Docker containers using a simple, readable configuration file.<p>With Docker Compose, you can specify services, networks, volumes, and other configurations needed to run an application composed of multiple containers. You can also define dependencies among containers, environment variables, exposed ports, etc.<p>Docker Compose uses a YAML configuration file to describe the application’s infrastructure. This file contains sections such as <em>services</em>, <em>networks</em>, <em>volumes</em>, etc., where you can define the different parts of your application and their configurations.<p>Here is an example <code>docker-compose.yml</code> for the Rust application that launches both the server and the PostgreSQL database:<pre class="giallo z-code"><code data-lang=yaml><span class=giallo-l><span class=z-comment>#</span><span class=z-comment> List of containers to launch</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">s</span><span class="z-entity z-name z-tag">ervices</span><span>:</span></span>
<span class=giallo-l><span class=z-comment>  #</span><span class=z-comment> Database container</span></span>
<span class=giallo-l><span class=z-comment>  #</span><span class=z-comment> We find the same parameters as in `docker run`</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">  d</span><span class="z-entity z-name z-tag">b</span><span>:</span></span>
<span class=giallo-l><span class=z-comment>    #</span><span class=z-comment> Specify the image to launch</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">    i</span><span class="z-entity z-name z-tag">mage</span><span>:</span><span class=z-string> p</span><span class=z-string>ostgres:latest</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">    r</span><span class="z-entity z-name z-tag">estart</span><span>:</span><span class=z-string> a</span><span class=z-string>lways</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">    e</span><span class="z-entity z-name z-tag">nvironment</span><span>:</span></span>
<span class=giallo-l><span>      -</span><span class=z-string> P</span><span class=z-string>OSTGRES_USER=postgres</span></span>
<span class=giallo-l><span>      -</span><span class=z-string> P</span><span class=z-string>OSTGRES_PASSWORD=postgres</span></span>
<span class=giallo-l><span>      -</span><span class=z-string> P</span><span class=z-string>GDATA=/var/lib/postgresql/data/pgdata</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">    e</span><span class="z-entity z-name z-tag">xpose</span><span>:</span></span>
<span class=giallo-l><span>      -</span><span class="z-constant z-numeric"> 5432</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">    v</span><span class="z-entity z-name z-tag">olumes</span><span>:</span></span>
<span class=giallo-l><span>      -</span><span class=z-string> d</span><span class=z-string>b:/var/lib/postgresql/data</span></span>
<span class=giallo-l><span class=z-comment>  #</span><span class=z-comment> Rust server</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">  a</span><span class="z-entity z-name z-tag">pi</span><span>:</span></span>
<span class=giallo-l><span class=z-comment>    #</span><span class=z-comment> Will build the Dockerfile in the directory containing docker-compose.yml</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">    b</span><span class="z-entity z-name z-tag">uild</span><span>:</span><span class="z-constant z-numeric"> .</span></span>
<span class=giallo-l><span class=z-comment>    #</span><span class=z-comment> Build the db service before api</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">    d</span><span class="z-entity z-name z-tag">epends_on</span><span>:</span></span>
<span class=giallo-l><span>      -</span><span class=z-string> d</span><span class=z-string>b</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">    p</span><span class="z-entity z-name z-tag">orts</span><span>:</span></span>
<span class=giallo-l><span>      -</span><span class=z-string> 8</span><span class=z-string>081:8081</span></span>
<span class=giallo-l><span class=z-comment>    #</span><span class=z-comment> The database URL changes—rather than @localhost</span></span>
<span class=giallo-l><span class=z-comment>    #</span><span class=z-comment> docker-compose makes db accessible under the name @db</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">    e</span><span class="z-entity z-name z-tag">nvironment</span><span>:</span></span>
<span class=giallo-l><span>      -</span><span class=z-string> D</span><span class=z-string>ATABASE_URL=postgres://postgres:postgres@db</span></span>
<span class=giallo-l><span class=z-comment>    #</span><span class=z-comment> Wait for the database to be ready before launching the server</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">    e</span><span class="z-entity z-name z-tag">ntrypoint</span><span>:</span><span class=z-string> b</span><span class=z-string>ash -c "sleep 5 && ./rust_api"</span></span>
<span class=giallo-l><span class=z-comment>#</span><span class=z-comment> Required for the database volume</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">v</span><span class="z-entity z-name z-tag">olumes</span><span>:</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">  d</span><span class="z-entity z-name z-tag">b</span><span>:</span></span>
<span class=giallo-l><span class="z-entity z-name z-tag">    d</span><span class="z-entity z-name z-tag">river</span><span>:</span><span class=z-string> l</span><span class=z-string>ocal</span></span></code></pre><p>Run with:<pre class="giallo z-code"><code data-lang=shellscript><span class=giallo-l><span class="z-entity z-name z-function">docker-compose</span><span class=z-string> up</span><span class="z-constant z-other"> -</span><span class="z-constant z-other">-build</span></span></code></pre><h3 id=podman>Podman</h3><p><a href=https://podman.io/ rel=external>Podman</a> is an open-source alternative to Docker. Docker and Podman are two popular containerization tools that share similar features but differ in architecture and security approach. Docker uses a client-server architecture, where the Docker daemon runs as a separate process and Docker commands are executed via the CLI. In contrast, Podman uses a daemonless architecture, meaning it runs directly as a regular user and does not require a separate daemon process. Thus, Podman can run without special privileges, limiting potential risks associated with running as superuser. See <a href=https://www.redhat.com/en/topics/containers/what-is-podman rel=external>What is podman?</a> for more information.<p>Podman also offers tools to manage <em>pods</em>, a topic outside the scope of this workshop.<h3 id=kubernetes>Kubernetes</h3><p>Kubernetes is an open-source container orchestration system that facilitates the deployment, management, and scaling of containerized applications. Using Kubernetes offers many benefits, such as fault tolerance, easier deployments, and management and scaling of containerized applications.</article><hr><nav id=post-nav><a class="post-nav-item post-nav-prev" href=https://willguimont.com/blog/bash-workshop/> <div class=nav-arrow>Previous</div> <span class=post-title>Bash Workshop</span> </a><a class="post-nav-item post-nav-next" href=https://willguimont.com/blog/silvascenes/> <div class=nav-arrow>Next</div> <span class=post-title>SilvaScenes</span> </a></nav></main><footer id=site-footer><p>© wigum::website, 2026<ul id=external-links><li><a rel=" me" href=https://github.com/willGuimont title=GitHub> <i class=icon style=--icon:url(data:image/svg+xml,%3Csvg%20role%3D%27img%27%20viewBox%3D%270%200%2024%2024%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%3Ctitle%3EGitHub%3C%2Ftitle%3E%3Cpath%20d%3D%27M12%20.297c-6.63%200-12%205.373-12%2012%200%205.303%203.438%209.8%208.205%2011.385.6.113.82-.258.82-.577%200-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422%2018.07%203.633%2017.7%203.633%2017.7c-1.087-.744.084-.729.084-.729%201.205.084%201.838%201.236%201.838%201.236%201.07%201.835%202.809%201.305%203.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93%200-1.31.465-2.38%201.235-3.22-.135-.303-.54-1.523.105-3.176%200%200%201.005-.322%203.3%201.23.96-.267%201.98-.399%203-.405%201.02.006%202.04.138%203%20.405%202.28-1.552%203.285-1.23%203.285-1.23.645%201.653.24%202.873.12%203.176.765.84%201.23%201.91%201.23%203.22%200%204.61-2.805%205.625-5.475%205.92.42.36.81%201.096.81%202.22%200%201.606-.015%202.896-.015%203.286%200%20.315.21.69.825.57C20.565%2022.092%2024%2017.592%2024%2012.297c0-6.627-5.373-12-12-12%27%2F%3E%3C%2Fsvg%3E)></i> <span>GitHub</span> </a><li><a rel=" me" href=https://bsky.app/profile/willguimont.bsky.social title=Bluesky> <i class=icon style=--icon:url(data:image/svg+xml,%3Csvg%20role%3D%27img%27%20viewBox%3D%270%200%20600%20530%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%3Cpath%20d%3D%27m135.72%2044.03c66.496%2049.921%20138.02%20151.14%20164.28%20205.46%2026.262-54.316%2097.782-155.54%20164.28-205.46%2047.98-36.021%20125.72-63.892%20125.72%2024.795%200%2017.712-10.155%20148.79-16.111%20170.07-20.703%2073.984-96.144%2092.854-163.25%2081.433%20117.3%2019.964%20147.14%2086.092%2082.697%20152.22-122.39%20125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937%200.51669-3.7077%207.8964-13.714%2040.255-67.233%20197.36-189.63%2071.766-64.444-66.128-34.605-132.26%2082.697-152.22-67.108%2011.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07%200-88.687%2077.742-60.816%20125.72-24.795z%27%20fill%3D%27%231185fe%27%2F%3E%3C%2Fsvg%3E)></i> <span>Bluesky</span> </a><li><a rel=" me" href=https://instagram.com/wilguimont title=Instagram> <i class=icon style=--icon:url(data:image/svg+xml,%3Csvg%20role%3D%27img%27%20viewBox%3D%270%200%2024%2024%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%3Ctitle%3EInstagram%3C%2Ftitle%3E%3Cpath%20d%3D%27M7.0301.084c-1.2768.0602-2.1487.264-2.911.5634-.7888.3075-1.4575.72-2.1228%201.3877-.6652.6677-1.075%201.3368-1.3802%202.127-.2954.7638-.4956%201.6365-.552%202.914-.0564%201.2775-.0689%201.6882-.0626%204.947.0062%203.2586.0206%203.6671.0825%204.9473.061%201.2765.264%202.1482.5635%202.9107.308.7889.72%201.4573%201.388%202.1228.6679.6655%201.3365%201.0743%202.1285%201.38.7632.295%201.6361.4961%202.9134.552%201.2773.056%201.6884.069%204.9462.0627%203.2578-.0062%203.668-.0207%204.9478-.0814%201.28-.0607%202.147-.2652%202.9098-.5633.7889-.3086%201.4578-.72%202.1228-1.3881.665-.6682%201.0745-1.3378%201.3795-2.1284.2957-.7632.4966-1.636.552-2.9124.056-1.2809.0692-1.6898.063-4.948-.0063-3.2583-.021-3.6668-.0817-4.9465-.0607-1.2797-.264-2.1487-.5633-2.9117-.3084-.7889-.72-1.4568-1.3876-2.1228C21.2982%201.33%2020.628.9208%2019.8378.6165%2019.074.321%2018.2017.1197%2016.9244.0645%2015.6471.0093%2015.236-.005%2011.977.0014%208.718.0076%208.31.0215%207.0301.0839m.1402%2021.6932c-1.17-.0509-1.8053-.2453-2.2287-.408-.5606-.216-.96-.4771-1.3819-.895-.422-.4178-.6811-.8186-.9-1.378-.1644-.4234-.3624-1.058-.4171-2.228-.0595-1.2645-.072-1.6442-.079-4.848-.007-3.2037.0053-3.583.0607-4.848.05-1.169.2456-1.805.408-2.2282.216-.5613.4762-.96.895-1.3816.4188-.4217.8184-.6814%201.3783-.9003.423-.1651%201.0575-.3614%202.227-.4171%201.2655-.06%201.6447-.072%204.848-.079%203.2033-.007%203.5835.005%204.8495.0608%201.169.0508%201.8053.2445%202.228.408.5608.216.96.4754%201.3816.895.4217.4194.6816.8176.9005%201.3787.1653.4217.3617%201.056.4169%202.2263.0602%201.2655.0739%201.645.0796%204.848.0058%203.203-.0055%203.5834-.061%204.848-.051%201.17-.245%201.8055-.408%202.2294-.216.5604-.4763.96-.8954%201.3814-.419.4215-.8181.6811-1.3783.9-.4224.1649-1.0577.3617-2.2262.4174-1.2656.0595-1.6448.072-4.8493.079-3.2045.007-3.5825-.006-4.848-.0608M16.953%205.5864A1.44%201.44%200%201%200%2018.39%204.144a1.44%201.44%200%200%200-1.437%201.4424M5.8385%2012.012c.0067%203.4032%202.7706%206.1557%206.173%206.1493%203.4026-.0065%206.157-2.7701%206.1506-6.1733-.0065-3.4032-2.771-6.1565-6.174-6.1498-3.403.0067-6.156%202.771-6.1496%206.1738M8%2012.0077a4%204%200%201%201%204.008%203.9921A3.9996%203.9996%200%200%201%208%2012.0077%27%2F%3E%3C%2Fsvg%3E)></i> <span>Instagram</span> </a><li><a href="https://scholar.google.com/citations?user=sZIyj3IAAAAJ&hl=en" rel=" me" title="Google Scholar"> <i class=icon style=--icon:url(data:image/svg+xml,%3Csvg%20role%3D%27img%27%20viewBox%3D%270%200%2024%2024%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%3Ctitle%3EGoogle%20Scholar%3C%2Ftitle%3E%3Cpath%20d%3D%27M5.242%2013.769L0%209.5%2012%200l12%209.5-5.242%204.269C17.548%2011.249%2014.978%209.5%2012%209.5c-2.977%200-5.548%201.748-6.758%204.269zM12%2010a7%207%200%201%200%200%2014%207%207%200%200%200%200-14z%27%2F%3E%3C%2Fsvg%3E)></i> <span>Google Scholar</span> </a><li><a rel=" me" href=https://x.com/WilliamGuimont title=Twitter> <i class=icon style=--icon:url(data:image/svg+xml,%3Csvg%20role%3D%27img%27%20width%3D%27300%27%20height%3D%27300.251%27%20version%3D%271.1%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%3Cpath%20d%3D%27M178.57%20127.15%20290.27%200h-26.46l-97.03%20110.38L89.34%200H0l117.13%20166.93L0%20300.25h26.46l102.4-116.59%2081.8%20116.59h89.34M36.01%2019.54H76.66l187.13%20262.13h-40.66%27%2F%3E%3C%2Fsvg%3E)></i> <span>Twitter</span> </a><li><a rel=" me" href=https://mastodon.social/@willGuimont title=Mastodon> <i class=icon style=--icon:url(data:image/svg+xml,%3Csvg%20role%3D%27img%27%20viewBox%3D%270%200%2024%2024%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%3Ctitle%3EMastodon%3C%2Ftitle%3E%3Cpath%20d%3D%27M23.268%205.313c-.35-2.578-2.617-4.61-5.304-5.004C17.51.242%2015.792%200%2011.813%200h-.03c-3.98%200-4.835.242-5.288.309C3.882.692%201.496%202.518.917%205.127.64%206.412.61%207.837.661%209.143c.074%201.874.088%203.745.26%205.611.118%201.24.325%202.47.62%203.68.55%202.237%202.777%204.098%204.96%204.857%202.336.792%204.849.923%207.256.38.265-.061.527-.132.786-.213.585-.184%201.27-.39%201.774-.753a.057.057%200%200%200%20.023-.043v-1.809a.052.052%200%200%200-.02-.041.053.053%200%200%200-.046-.01%2020.282%2020.282%200%200%201-4.709.545c-2.73%200-3.463-1.284-3.674-1.818a5.593%205.593%200%200%201-.319-1.433.053.053%200%200%201%20.066-.054c1.517.363%203.072.546%204.632.546.376%200%20.75%200%201.125-.01%201.57-.044%203.224-.124%204.768-.422.038-.008.077-.015.11-.024%202.435-.464%204.753-1.92%204.989-5.604.008-.145.03-1.52.03-1.67.002-.512.167-3.63-.024-5.545zm-3.748%209.195h-2.561V8.29c0-1.309-.55-1.976-1.67-1.976-1.23%200-1.846.79-1.846%202.35v3.403h-2.546V8.663c0-1.56-.617-2.35-1.848-2.35-1.112%200-1.668.668-1.67%201.977v6.218H4.822V8.102c0-1.31.337-2.35%201.011-3.12.696-.77%201.608-1.164%202.74-1.164%201.311%200%202.302.5%202.962%201.498l.638%201.06.638-1.06c.66-.999%201.65-1.498%202.96-1.498%201.13%200%202.043.395%202.74%201.164.675.77%201.012%201.81%201.012%203.12z%27%2F%3E%3C%2Fsvg%3E)></i> <span>Mastodon</span> </a></ul></footer><span class=hidden id=copy-code-text>Copy Code</span><span class=hidden id=search-index>https://willguimont.com/search_index.en.json</span><span class=hidden id=more-matches-text>$MATCHES more matches</span><style>:root{--alert-note-text:"Note";--alert-tip-text:"Tip";--alert-important-text:"Important";--alert-warning-text:"Warning";--alert-caution-text:"Caution"}</style>