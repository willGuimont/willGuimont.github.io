<!doctype html><html data-theme=dark lang=en xmlns=http://www.w3.org/1999/xhtml><head><meta charset=UTF-8><meta content="William Guimont-Martin's personal website" name=description><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#0066ff name=theme-color><meta content=#66ccff media=(prefers-color-scheme:dark) name=theme-color><meta content="default-src 'none';font-src 'self';img-src 'self' https: data:;media-src 'self' https:;style-src 'self' 'unsafe-inline';frame-src https://player.vimeo.com https://www.youtube-nocookie.com https://toot.community;base-uri 'none';form-action 'none';connect-src 'self' https://mastodon.social https://toot.community;script-src 'self' 'self'" http-equiv=content-security-policy><title>Element of Errors Handling - wigum::website</title><link href=https://willguimont.com/blog/error-handling/ rel=canonical><link href=https://mastodon.social/@willGuimont rel=me><meta content=@willGuimont@mastodon.social name=fediverse:creator><link href=https://willguimont.com/favicon.png rel=icon type=image/png><link href=https://willguimont.com/apple-touch-icon.png rel=apple-touch-icon sizes=180x180 type=image/png><link title="wigum::website - RSS Feed" href=https://willguimont.com/rss.xml rel=alternate type=application/rss+xml><link title="wigum::website - Atom Feed" href=https://willguimont.com/atom.xml rel=alternate type=application/atom+xml><style>:root{--accent-color:#06f}[data-theme=dark]{--accent-color:#6cf}@media (prefers-color-scheme:dark){:root:not([data-theme=light]){--accent-color:#6cf}}</style><link href=https://willguimont.com/style.css rel=stylesheet><link href=https://willguimont.com/icons.css rel=stylesheet><link href=https://willguimont.com/custom.css rel=stylesheet><link media="(prefers-color-scheme: light)" href=https://willguimont.com/syntax-theme-light.css rel=stylesheet><link media="(prefers-color-scheme: dark)" href=https://willguimont.com/syntax-theme-dark.css rel=stylesheet><script defer src=https://willguimont.com/closable.js></script><script defer src=https://willguimont.com/copy-button.js></script><script defer src=https://willguimont.com/fuse.js></script><script defer src=https://willguimont.com/search-fuse.js></script><script defer src=https://willguimont.com/theme-switcher.js></script><meta content=wigum::website property=og:site_name><meta content="Element of Errors Handling - wigum::website" property=og:title><meta content=https://willguimont.com/blog/error-handling/ property=og:url><meta content="A deep dive into error handling mechanisms" property=og:description><meta content=en_US property=og:locale><body><header id=site-nav><nav><a href=#main-content tabindex=0> Skip to Main Content </a><ul><li id=home><a href=https://willguimont.com> <i class=icon></i>wigum::website</a><li class=divider><li><a href=https://willguimont.com/blog/>Blog</a><li><details class=closable><summary>Links</summary> <ul><li><a class=external href=https://github.com/willGuimont target=_blank>GitHub</a><li><a class=external href=https://www.youtube.com/@willGuimont target=_blank>YouTube</a><li><a class=external href=https://www.linkedin.com/in/william-guimont-martin/ target=_blank>LinkedIn</a><li><a class=external href=https://www.thingiverse.com/wigum/designs target=_blank>Thingiverse</a><li><a class=external href=https://cults3d.com/en/users/wigum/ target=_blank>Cults3D</a><li><a class=external href=https://www.instagram.com/wilguimont/ target=_blank>Instagram</a><li><a href="https://scholar.google.com/citations?user=sZIyj3IAAAAJ&hl=en" class=external target=_blank>Google Scholar</a><li><a class=external href=https://www.researchgate.net/profile/William-Guimont-Martin target=_blank>ResearchGate</a><li><a class=external href=https://mastodon.social/@willGuimont target=_blank>Mastodon</a><li><a class=external href=https://ko-fi.com/wigum target=_blank>Coffee</a></ul></details><li id=tags><a class=circle href=https://willguimont.com/tags title=tags> <i class=icon></i> </a><li id=search><button class=circle id=search-toggle title=Search><i class=icon></i></button><li id=theme-switcher><details class=closable><summary class=circle title=Theme><i class=icon></i></summary> <ul><li><button title="Switch to Light Theme" class=circle id=theme-light><i class=icon></i></button><li><button title="Switch to Dark Theme" class=circle id=theme-dark><i class=icon></i></button><li><button title="Use System Theme" class=circle id=theme-system><i class=icon></i></button></ul></details><li id=feed><details class=closable><summary class=circle title=Feed><i class=icon></i></summary> <ul><li><a href=https://willguimont.com/rss.xml>RSS</a><li><a href=https://willguimont.com/atom.xml>Atom</a></ul></details><li id=repo><a class=circle href=https://github.com/willGuimont/willGuimont.github.io title=Repository> <i class=icon></i> </a></ul></nav><div id=search-container><label class=visually-hidden for=search-bar>Search</label><input placeholder="Search for…" autocomplete=off disabled id=search-bar type=search><div id=search-results-container><div id=search-results></div></div></div></header><main id=main-content><article><div id=heading><p><small> <time datetime=" 2025-07-25T00:00:00+00:00">Published on July 25, 2025</time></small><h1>Element of Errors Handling</h1><p><small><span>By William Guimont-Martin</span><span> • </span><span>16 minutes read</span><span> • </span></small><ul class=tags><a class=tag href=https://willguimont.com/tags>tags:</a><li><a class=tag href=https://willguimont.com/tags/computing-sciences/>Computing Sciences</a><li><a class=tag href=https://willguimont.com/tags/programming/>Programming</a><li><a class=tag href=https://willguimont.com/tags/software-development/>Software Development</a></ul><br></div><div id=buttons-container><details class=closable id=toc><summary title="Table of Contents"><i class=icon></i></summary> <div><strong class=title>Table of Contents</strong><div><ol><li><a href=https://willguimont.com/blog/error-handling/#trying-to-catch-lightning-in-a-bottle-exceptions-java-and-friends>Trying to Catch Lightning in a Bottle Exceptions (Java and Friends)</a><li><a href=https://willguimont.com/blog/error-handling/#going-somewhere-with-errors-go>Going Somewhere with Errors (Go)</a><ol><li><a href=https://willguimont.com/blog/error-handling/#zig>Zig</a><li><a href=https://willguimont.com/blog/error-handling/#odin>Odin</a></ol><li><a href=https://willguimont.com/blog/error-handling/#playing-tag-with-errors-rust>Playing Tag with Errors (Rust)</a><ol><li><a href=https://willguimont.com/blog/error-handling/#a-monadic-digression>A Monadic Digression</a></ol><li><a href=https://willguimont.com/blog/error-handling/#a-monad-is-just-a-monoid-in-the-category-of-endofunctors-what-s-the-problem-haskell>A monad is just a monoid in the category of endofunctors, what’s the problem? (Haskell)</a><ol><li><a href=https://willguimont.com/blog/error-handling/#excepting-monads>Excepting Monads</a><li><a href=https://willguimont.com/blog/error-handling/#parsing-and-non-empty-chains-scala>Parsing and Non-Empty Chains (Scala)</a></ol><li><a href=https://willguimont.com/blog/error-handling/#effect-systems-haskell>Effect Systems (Haskell++)</a><li><a href=https://willguimont.com/blog/error-handling/#trust-but-verify-assert-d>Trust, but verify assert (D)</a><li><a href=https://willguimont.com/blog/error-handling/#let-it-go-crash-elixir>Let It Go Crash (Elixir)</a><li><a href=https://willguimont.com/blog/error-handling/#conclusion-errors-are-the-norm-not-the-exception>Conclusion: Errors Are the Norm, Not the Exception</a></ol></div></div></details><a title="Go to Top" href=#top id=go-to-top><i class=icon></i></a><a href="https://shareopenly.org/share/?url=https://willguimont.com/blog/error-handling/&text=A%20deep%20dive%20into%20error%20handling%20mechanisms" id=share title=Share><i class=icon></i></a><a title="File an Issue" href=https://github.com/willGuimont/willGuimont.github.io/issues id=issue><i class=icon></i></a></div><h2>Table of Contents</h2><ol><li><a href=https://willguimont.com/blog/error-handling/#trying-to-catch-lightning-in-a-bottle-exceptions-java-and-friends>Trying to Catch Lightning in a Bottle Exceptions (Java and Friends)</a><li><a href=https://willguimont.com/blog/error-handling/#going-somewhere-with-errors-go>Going Somewhere with Errors (Go)</a><ol><li><a href=https://willguimont.com/blog/error-handling/#zig>Zig</a><li><a href=https://willguimont.com/blog/error-handling/#odin>Odin</a></ol><li><a href=https://willguimont.com/blog/error-handling/#playing-tag-with-errors-rust>Playing Tag with Errors (Rust)</a><ol><li><a href=https://willguimont.com/blog/error-handling/#a-monadic-digression>A Monadic Digression</a></ol><li><a href=https://willguimont.com/blog/error-handling/#a-monad-is-just-a-monoid-in-the-category-of-endofunctors-what-s-the-problem-haskell>A monad is just a monoid in the category of endofunctors, what’s the problem? (Haskell)</a><ol><li><a href=https://willguimont.com/blog/error-handling/#excepting-monads>Excepting Monads</a><li><a href=https://willguimont.com/blog/error-handling/#parsing-and-non-empty-chains-scala>Parsing and Non-Empty Chains (Scala)</a></ol><li><a href=https://willguimont.com/blog/error-handling/#effect-systems-haskell>Effect Systems (Haskell++)</a><li><a href=https://willguimont.com/blog/error-handling/#trust-but-verify-assert-d>Trust, but verify assert (D)</a><li><a href=https://willguimont.com/blog/error-handling/#let-it-go-crash-elixir>Let It Go Crash (Elixir)</a><li><a href=https://willguimont.com/blog/error-handling/#conclusion-errors-are-the-norm-not-the-exception>Conclusion: Errors Are the Norm, Not the Exception</a></ol><p>Errors are everywhere. Any computation, IO operation, database access, or API call – any of them can fail. Despite this, most programming languages either struggle to make error handling correct or make it painful. It’s almost always easy to write the happy path. The moment something goes wrong, though, most languages make the not-so-happy path either verbose, implicit, or dangerously ignorable.<p>Handling errors well should be a first-class concern. It feels as if errors are just an afterthought in mainstream languages, added inelegantly out of necessity.<p>This blog post stems from some experimentation on error handling I did back in 2021. At the end of my undergraduate studies in software engineering, we were assigned a final project in collaboration with an industry partner. They gave us <em>carte blanche</em> on the choice of technology. Looking to try less mainstream languages and explore new paradigms, we decided to explore and compare several less conventional stacks – paying particular attention to how each one approached error handling, since our project required high reliability and robustness.<h2 id=trying-to-catch-lightning-in-a-bottle-exceptions-java-and-friends><code>Try</code>ing to <code>Catch</code> <del>Lightning in a Bottle</del> Exceptions (Java and Friends)</h2><p>The most well-known model is the <code>try/catch</code> mechanism. You throw an error and hope someone, somewhere, catches it. Otherwise, your program crashes unceremoniously.<p>It’s an <em>easy</em> method for the error generating code, throw the exception and forget about it, but not simple. This is similar to the distinction between <em>simple</em> and <em>easy</em> made by Rich Hickey in his talk “<a class=external href=https://www.infoq.com/presentations/Simple-Made-Easy/ target=_blank>Simple Made Easy</a>”. Exceptions are <strong>complecting</strong> by nature, they intertwine normal control flow with error handling. The control flow is no longer linear and predictable, you climb back up the stack looking for a handler.<p>They let you skip instructions, bubble errors up several layers, and bypass normal control flow. In a way, they are sugar-coated <code>goto</code>s that jump through stack frames.<p>Yes, <code>try/catch/finally</code> blocks and RAII (in C++/Java with try-with-resources) can clean things up nicely (although, I prefer using <code>defer</code> or <code>err_defer</code>), but you’re still left with a system where it’s not obvious what code might throw.<p>Java attempted to solve the uncertainty around which operations might throw exceptions through checked exceptions, but that just shifted the problem. You now have to annotate everything, tracing all possible failure paths and punting the problem upstream. Most Java developers end up defaulting to unchecked exceptions anyway, sacrificing safety for sanity. Even Robert C. Martin said in Clean Code:<blockquote><p>Checked exceptions can sometimes be useful if you are writing a critical library: You must catch them. But in general application development, the dependency costs outweigh the benefits.<p>– Robert C. Martin. Clean Code. 2008.</blockquote><p>Despite their limitations, exceptions are still very much useful for their convenience and ease of use in simple cases. That said, while it can be convenient to let domain exceptions bubble up – for instance, in a REST API handler where you want a 400 Bad Request – you’re still playing with possibly impossible-to-predict, and more importantly difficult to debug, control flow. This is especially true in large codebases with many layers of abstraction, where an exception thrown deep in the stack can be caught and handled far away from its origin, making it hard to trace the error’s source. While you can try to limit this with coding standards and best practices, it remains challenging and cumbersome if the language does not provide good alternatives.<h2 id=going-somewhere-with-errors-go><code>Go</code>ing Somewhere with Errors (Go)</h2><p>Go brought back the C-style return code (i.e., non-zero return for errors), modernized as error values returned by the function, now with <code>nil</code> as the successful return value. You call a function, and it returns both result and error. By convention, the error is the last return value.<pre class="giallo z-code"><code data-lang=go><span class=giallo-l><span class=z-keyword>import</span><span> (</span></span>
<span class=giallo-l><span class=z-string>    "</span><span class=z-string>errors</span><span class=z-string>"</span></span>
<span class=giallo-l><span class=z-string>    "</span><span class=z-string>fmt</span><span class=z-string>"</span></span>
<span class=giallo-l><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//</span><span class=z-comment> formatNaturalNumber validates the input is non-negative and returns it as a string.</span></span>
<span class=giallo-l><span class=z-keyword>func</span><span class="z-entity z-name z-function"> formatNaturalNumber</span><span>(</span><span>input</span><span class=z-storage> int</span><span>)</span><span> (</span><span class=z-storage>string</span><span>,</span><span class=z-storage> error</span><span>)</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>    if</span><span class="z-variable z-other"> input</span><span class=z-keyword> &lt;</span><span class="z-constant z-numeric"> 0</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>        return</span><span class=z-string> "</span><span class=z-string>"</span><span>,</span><span class="z-variable z-other"> errors</span><span>.</span><span class="z-entity z-name z-function">New</span><span>(</span><span class=z-string>"</span><span class=z-string>input is not a natural number: value is negative</span><span class=z-string>"</span><span>)</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>    return</span><span class="z-variable z-other"> fmt</span><span>.</span><span class="z-entity z-name z-function">Sprintf</span><span>(</span><span class=z-string>"</span><span class=z-string>Natural Number: </span><span class="z-constant z-other">%d</span><span class=z-string>"</span><span>,</span><span class="z-variable z-other"> input</span><span>)</span><span>,</span><span class="z-constant z-language"> nil</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>func</span><span class="z-entity z-name z-function"> main</span><span>(</span><span>)</span><span> {</span></span>
<span class=giallo-l><span class="z-variable z-other">    input</span><span class=z-keyword> :=</span><span class="z-constant z-numeric"> 42</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-variable z-other">    result</span><span>,</span><span class="z-variable z-other"> err</span><span class=z-keyword> :=</span><span class="z-entity z-name z-function"> formatNaturalNumber</span><span>(</span><span class="z-variable z-other">input</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>    if</span><span class="z-variable z-other"> err</span><span class=z-keyword> !=</span><span class="z-constant z-language"> nil</span><span> {</span></span>
<span class=giallo-l><span class=z-comment>        //</span><span class=z-comment> Handle error and exit early</span></span>
<span class=giallo-l><span class="z-variable z-other">        fmt</span><span>.</span><span class="z-entity z-name z-function">Printf</span><span>(</span><span class=z-string>"</span><span class=z-string>Error: </span><span class="z-constant z-other">%v</span><span class="z-constant z-character">\n</span><span class=z-string>"</span><span>,</span><span class="z-variable z-other"> err</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>        return</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>    //</span><span class=z-comment> Continue with the success path</span></span>
<span class=giallo-l><span class="z-variable z-other">    fmt</span><span>.</span><span class="z-entity z-name z-function">Println</span><span>(</span><span class="z-variable z-other">result</span><span>)</span></span>
<span class=giallo-l><span>}</span></span></code></pre><p>This makes error handling explicit, which is a good thing: you see where errors can occur and have to deal with them directly. You can follow the code, and you should be able to know exactly what happens when an error is returned. You can handle the error here and there, or return it to the function’s caller.<p>But this explicitness comes at the cost of verbosity and boilerplate. You will see <code>if err != nil</code> peppered everywhere. Also, Go gives you no tools to help with error handling. You’re mostly on your own to handle errors consistently. Go does not provide any syntactic sugar for error handling, i.e., no <code>try/catch</code>, no pattern matching, no monadic operators. Just <code>if err != nil</code> over and over. The little Go I did write felt like it required a lot of duplicate boilerplate code to handle errors properly. I had to keep <code>if err != nil {}</code> in my clipboard for quick pasting.<p>You end up either duplicating error propagation boilerplate or using helper functions to hide the verbosity (e.g., <a class=external href=https://pkg.go.dev/errors#Join target=_blank>errors.Join</a>) – at which point you’ve reinvented a monad poorly.<p>To its credit, Go includes one elegant feature for cleanup after an error might have occurred: <code>defer</code>. It allows you to schedule resource cleanup (like closing files or releasing locks) regardless of how the function exits, which pairs well with manual error handling:<pre class="giallo z-code"><code data-lang=go><span class=giallo-l><span class="z-variable z-other">f</span><span>,</span><span class="z-variable z-other"> err</span><span class=z-keyword> :=</span><span class="z-variable z-other"> os</span><span>.</span><span class="z-entity z-name z-function">Open</span><span>(</span><span class=z-string>"</span><span class=z-string>file.txt</span><span class=z-string>"</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>if</span><span class="z-variable z-other"> err</span><span class=z-keyword> !=</span><span class="z-constant z-language"> nil</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>    return</span><span class="z-variable z-other"> err</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l><span class=z-keyword>defer</span><span class="z-variable z-other"> f</span><span>.</span><span class="z-entity z-name z-function">Close</span><span>(</span><span>)</span><span class=z-comment> //</span><span class=z-comment> Yes, this could also return an error and would need to be handled correctly</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-variable z-other">result</span><span>,</span><span class="z-variable z-other"> err</span><span class=z-keyword> :=</span><span class="z-entity z-name z-function"> doSomething</span><span>(</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>if</span><span class="z-variable z-other"> err</span><span class=z-keyword> !=</span><span class="z-constant z-language"> nil</span><span> {</span></span>
<span class=giallo-l><span class=z-comment>    //</span><span class=z-comment> f will still be closed!</span></span>
<span class=giallo-l><span class=z-keyword>    return</span><span class="z-variable z-other"> err</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h3 id=zig>Zig</h3><p>Zig handles errors a bit differently. Instead of adding an explicit error return value, Zig uses error union types. By adding <code>!</code> before a type, you indicate that the function can return either a value of that type or an error, e.g., <code>fn doSomething() !i32</code>. Thus taking the union of the error set and the normal return type. You can optionally narrow down the error set to specific errors prefixing the error type, e.g., <code>fn doSomethingElse() ErrorType!ReturnType</code>.<p>In addition, Zig has built-in syntax for propagating errors with <code>try</code> and <code>catch</code>. When you call a function that can return an error, you can use <code>try</code> to automatically propagate the error if it occurs, or get the value if it succeeds. With <code>catch</code>, you can provide a default value or handle the error in place passing the error to a lambda.<pre class="giallo z-code"><code data-lang=zig><span class=giallo-l><span class=z-keyword>const</span><span> std</span><span class=z-keyword> =</span><span class="z-support z-function"> @import</span><span>(</span><span class=z-string>"</span><span class=z-string>std</span><span class=z-string>"</span><span>)</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>const</span><span> DivisionError</span><span class=z-keyword> =</span><span class=z-keyword> error</span><span>{</span></span>
<span class=giallo-l><span>    DivisionByZero</span><span>,</span></span>
<span class=giallo-l><span>}</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-storage>fn</span><span class="z-entity z-name z-function"> divide</span><span>(</span><span>x</span><span>:</span><span class=z-keyword> i32</span><span>,</span><span> y</span><span>:</span><span class=z-keyword> i32</span><span>) </span><span class=z-keyword>!</span><span class=z-keyword>i32</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>    if</span><span> (</span><span>y</span><span class=z-keyword> ==</span><span class="z-constant z-numeric"> 0</span><span>) </span><span class=z-keyword>return</span><span> DivisionError</span><span>.</span><span>DivisionByZero</span><span>;</span></span>
<span class=giallo-l><span class=z-keyword>    return</span><span class="z-support z-function"> @divTrunc</span><span>(</span><span>x</span><span>,</span><span> y</span><span>)</span><span>;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//</span><span class=z-comment> performCalculation uses 'try' to propagate errors to its caller</span></span>
<span class=giallo-l><span class=z-storage>fn</span><span class="z-entity z-name z-function"> performCalculation</span><span>(</span><span>a</span><span>:</span><span class=z-keyword> i32</span><span>,</span><span> b</span><span>:</span><span class=z-keyword> i32</span><span>) </span><span class=z-keyword>!</span><span class=z-keyword>i32</span><span> {</span></span>
<span class=giallo-l><span class=z-comment>    //</span><span class=z-comment> If divide returns an error, performCalculation exits here and returns the error</span></span>
<span class=giallo-l><span class=z-keyword>    const</span><span> val</span><span class=z-keyword> =</span><span class=z-keyword> try</span><span class="z-entity z-name z-function"> divide</span><span>(</span><span>a</span><span>,</span><span> b</span><span>)</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>    //</span><span class=z-comment> This line only executes if divide was successful</span></span>
<span class=giallo-l><span class=z-keyword>    return</span><span> val</span><span class=z-keyword> +</span><span class="z-constant z-numeric"> 10</span><span>;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>pub</span><span class=z-storage> fn</span><span class="z-entity z-name z-function"> main</span><span>() </span><span class=z-keyword>!</span><span class=z-keyword>void</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>    const</span><span> result</span><span class=z-keyword> =</span><span class="z-entity z-name z-function"> performCalculation</span><span>(</span><span class="z-constant z-numeric">10</span><span>,</span><span class="z-constant z-numeric"> 0</span><span>) </span><span class=z-keyword>catch</span><span class=z-keyword> |</span><span>err</span><span class=z-keyword>|</span><span> {</span></span>
<span class=giallo-l><span>        std</span><span>.</span><span>debug</span><span>.</span><span class="z-entity z-name z-function">print</span><span>(</span><span class=z-string>"</span><span class=z-string>Flow interrupted by error: {}</span><span class="z-constant z-character">\n</span><span class=z-string>"</span><span>,</span><span> .</span><span>{</span><span>err</span><span>})</span><span>;</span></span>
<span class=giallo-l><span class=z-keyword>        return</span><span>;</span></span>
<span class=giallo-l><span>    }</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    std</span><span>.</span><span>debug</span><span>.</span><span class="z-entity z-name z-function">print</span><span>(</span><span class=z-string>"</span><span class=z-string>Final Result: {}</span><span class="z-constant z-character">\n</span><span class=z-string>"</span><span>,</span><span> .</span><span>{</span><span>result</span><span>})</span><span>;</span></span>
<span class=giallo-l><span>}</span></span></code></pre><p>This minimizes boilerplate while keeping error handling explicit. I quite like this approach, as it makes error propagation concise without losing clarity.<p>Zig also has <code>defer</code> for cleanup, similar to Go, but it adds <code>errdefer</code>. <code>errdefer</code> is used when you want to clean up resources only if an error occurs. For example, if you allocate a struct and an error happens later, you can use <code>errdefer</code> to free that struct only in the error case, and return the created struct on success.<pre class="giallo z-code"><code data-lang=zig><span class=giallo-l><span class=z-keyword>const</span><span> std</span><span class=z-keyword> =</span><span class="z-support z-function"> @import</span><span>(</span><span class=z-string>"</span><span class=z-string>std</span><span class=z-string>"</span><span>)</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>const</span><span> ProcessError</span><span class=z-keyword> =</span><span class=z-keyword> error</span><span>{</span></span>
<span class=giallo-l><span>    StepTwoFailed</span><span>,</span></span>
<span class=giallo-l><span>}</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-storage>fn</span><span class="z-entity z-name z-function"> complexOperation</span><span>() </span><span class=z-keyword>!</span><span class=z-keyword>void</span><span> {</span></span>
<span class=giallo-l><span>    std</span><span>.</span><span>debug</span><span>.</span><span class="z-entity z-name z-function">print</span><span>(</span><span class=z-string>"</span><span class=z-string>Step 1: Resource allocated.</span><span class="z-constant z-character">\n</span><span class=z-string>"</span><span>,</span><span> .</span><span>{})</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>    //</span><span class=z-comment> errdefer will ONLY run if this function returns an error</span></span>
<span class=giallo-l><span class=z-keyword>    errdefer</span><span> {</span></span>
<span class=giallo-l><span>        std</span><span>.</span><span>debug</span><span>.</span><span class="z-entity z-name z-function">print</span><span>(</span><span class=z-string>"</span><span class=z-string>Cleanup: Rolling back Step 1 due to failure.</span><span class="z-constant z-character">\n</span><span class=z-string>"</span><span>,</span><span> .</span><span>{})</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>    const</span><span> failure_condition</span><span class=z-keyword> =</span><span class=z-keyword> true</span><span>;</span></span>
<span class=giallo-l><span class=z-keyword>    if</span><span> (</span><span>failure_condition</span><span>) {</span></span>
<span class=giallo-l><span>        std</span><span>.</span><span>debug</span><span>.</span><span class="z-entity z-name z-function">print</span><span>(</span><span class=z-string>"</span><span class=z-string>Step 2: Encountered an issue.</span><span class="z-constant z-character">\n</span><span class=z-string>"</span><span>,</span><span> .</span><span>{})</span><span>;</span></span>
<span class=giallo-l><span class=z-keyword>        return</span><span> ProcessError</span><span>.</span><span>StepTwoFailed</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    std</span><span>.</span><span>debug</span><span>.</span><span class="z-entity z-name z-function">print</span><span>(</span><span class=z-string>"</span><span class=z-string>Step 3: Success! errdefer will not run.</span><span class="z-constant z-character">\n</span><span class=z-string>"</span><span>,</span><span> .</span><span>{})</span><span>;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>pub</span><span class=z-storage> fn</span><span class="z-entity z-name z-function"> main</span><span>() </span><span class=z-keyword>!</span><span class=z-keyword>void</span><span> {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    complexOperation</span><span>() </span><span class=z-keyword>catch</span><span class=z-keyword> |</span><span>err</span><span class=z-keyword>|</span><span> {</span></span>
<span class=giallo-l><span>        std</span><span>.</span><span>debug</span><span>.</span><span class="z-entity z-name z-function">print</span><span>(</span><span class=z-string>"</span><span class=z-string>Final result: {}</span><span class="z-constant z-character">\n</span><span class=z-string>"</span><span>,</span><span> .</span><span>{</span><span>err</span><span>})</span><span>;</span></span>
<span class=giallo-l><span>    }</span><span>;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span></code></pre><h3 id=odin>Odin</h3><p>I recently started experimenting with Odin, which has some interesting ideas around error handling. Instead of considering errors as exceptions or special types, Odin treats them as regular return values. As it is the case for Go, Odin conventionally returns an error as the last return value of a function. Unlike Zig, which uses error unions that require declaring error types using <code>error{}</code>, Odin simply treats non-zero return values as errors. This is paired with Odin’s commitment to make zero values useful defaults, so a function returning zero for an error indicates success.<pre class="giallo z-code"><code data-lang=plain><span class=giallo-l><span>package main</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>import "core:fmt"</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>Division_Error :: enum {</span></span>
<span class=giallo-l><span>    None, // This is the zero value, indicating no error. Variables of this type default to None (0).</span></span>
<span class=giallo-l><span>    Division_By_Zero,</span></span>
<span class=giallo-l><span>    Negative_Input,</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>// Function returns a result and an error enum</span></span>
<span class=giallo-l><span>divide_positive :: proc(x, y: int) -> (int, Division_Error) {</span></span>
<span class=giallo-l><span>    if y == 0 do return 0, .Division_By_Zero</span></span>
<span class=giallo-l><span>    if y &lt; 0 || x &lt; 0 do return 0, .Negative_Input</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    return x / y, .None</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>main :: proc() {</span></span>
<span class=giallo-l><span>    x, y := 10, 0</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    res, err := divide_positive(x, y)</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span>    if err != .None {</span></span>
<span class=giallo-l><span>        fmt.printf("Error encountered: %v\n", err)</span></span>
<span class=giallo-l><span>        return</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    fmt.printf("Result: %d\n", res)</span></span>
<span class=giallo-l><span>}</span></span></code></pre><p>But Odin goes further with built-in operators to streamline error handling. Assuming the last return value is the error, and that any non-zero value indicates an error, Odin provides <code>or_else</code>, <code>or_return</code>, <code>or_continue</code>, and <code>or_break</code> operators to handle errors concisely:<ul><li><code>or_else</code> allows you to provide a default value if an error occurs.<li><code>or_return</code> will return from the current function if an error occurs.<li><code>or_continue</code> and <code>or_break</code> can be used in loops to skip iterations or exit loops on errors.</ul><pre class="giallo z-code"><code data-lang=plain><span class=giallo-l><span>package main</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>import "core:fmt"</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>Division_Error :: enum {</span></span>
<span class=giallo-l><span>    None,</span></span>
<span class=giallo-l><span>    Division_By_Zero,</span></span>
<span class=giallo-l><span>    Negative_Input,</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>divide_positive :: proc(x, y: int) -> (int, Division_Error) {</span></span>
<span class=giallo-l><span>    if y == 0 do return 0, .Division_By_Zero</span></span>
<span class=giallo-l><span>    if y &lt; 0 || x &lt; 0 do return 0, .Negative_Input</span></span>
<span class=giallo-l><span>    return x / y, .None</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>// wrapper_proc demonstrates or_return</span></span>
<span class=giallo-l><span>wrapper_proc :: proc(a, b: int) -> (val: int, error_out: Division_Error) {</span></span>
<span class=giallo-l><span>    // Because parameters are named, or_return knows to put </span></span>
<span class=giallo-l><span>    // the error into 'error_out' and return.</span></span>
<span class=giallo-l><span>    // Named return values, as everything in Odin, are zero-initialized.</span></span>
<span class=giallo-l><span>    res := divide_positive(a, b) or_return </span></span>
<span class=giallo-l><span>    return res + 100, .None</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>main :: proc() {</span></span>
<span class=giallo-l><span>    // 1. Example using or_return (via wrapper)</span></span>
<span class=giallo-l><span>    val, err := wrapper_proc(10, 0)</span></span>
<span class=giallo-l><span>    if err != .None {</span></span>
<span class=giallo-l><span>        fmt.printf("wrapper_proc failed: %v\n", err)</span></span>
<span class=giallo-l><span>    } else {</span></span>
<span class=giallo-l><span>        fmt.printf("wrapper_proc result: %d\n", val)</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    // 2. Example using or_else</span></span>
<span class=giallo-l><span>    // or_else provides a fallback value if the second return is not .None/false</span></span>
<span class=giallo-l><span>    final_res := divide_positive(20, -5) or_else 999</span></span>
<span class=giallo-l><span>    fmt.printf("divide_positive with or_else fallback: %d\n", final_res)</span></span>
<span class=giallo-l><span>}</span></span></code></pre><p>Odin’s approach is reminiscent of Go’s explicit error handling but adds syntactic sugar to reduce boilerplate. From these <em>errors as values</em> methods, this is probably my favorite. It builds on Go’s explicit error handling while providing operators like <code>or_return</code> to streamline common patterns. It does not require separate error construction like Zig, making it conceptually simpler. Overall, Odin strikes a nice balance between explicitness and elegance in error handling.<h2 id=playing-tag-with-errors-rust>Playing Tag with Errors (Rust)</h2><p>Rust’s tagged unions <code>Result&lt;T, E></code> and <code>Option&lt;T></code> types offers a different approach. Errors are in the type system. The compiler forces you to handle them - or explicitly ignore them (e.g., with <code>unwrap</code>, <code>expect</code>, etc.). You can use Rust’s pattern matching to destructure and handle errors explicitly.<p>Rust also provides the <code>?</code> operator for concise error propagation:<pre class="giallo z-code"><code data-lang=rust><span class=giallo-l><span>#</span><span>[</span><span>derive</span><span>(</span><span class="z-entity z-name z-type">Debug</span><span>)</span><span>]</span></span>
<span class=giallo-l><span class=z-storage>enum</span><span class="z-entity z-name z-type"> MyError</span><span> {</span><span class="z-entity z-name z-type"> InvalidInput</span><span> }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>fn</span><span class="z-entity z-name z-function"> divide</span><span>(</span><span class="z-variable z-other">x</span><span class=z-keyword>:</span><span class="z-entity z-name z-type"> i32</span><span>,</span><span class="z-variable z-other"> y</span><span class=z-keyword>:</span><span class="z-entity z-name z-type"> i32</span><span>)</span><span class=z-keyword> -></span><span class="z-entity z-name z-type"> Result</span><span>&lt;</span><span class="z-entity z-name z-type">i32</span><span>,</span><span class="z-entity z-name z-type"> MyError</span><span>></span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>    if</span><span class="z-variable z-other"> y</span><span class=z-keyword> ==</span><span class="z-constant z-numeric"> 0</span><span> {</span><span class=z-keyword> return</span><span class="z-entity z-name z-type"> Err</span><span>(</span><span class="z-entity z-name z-type">MyError</span><span class=z-keyword>::</span><span class="z-entity z-name z-type">InvalidInput</span><span>)</span><span>;</span><span> }</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">    Ok</span><span>(</span><span class="z-variable z-other">x</span><span class=z-keyword> /</span><span class="z-variable z-other"> y</span><span>)</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>fn</span><span class="z-entity z-name z-function"> calculate</span><span>(</span><span>)</span><span class=z-keyword> -></span><span class="z-entity z-name z-type"> Result</span><span>&lt;</span><span class="z-entity z-name z-type">i32</span><span>,</span><span class="z-entity z-name z-type"> MyError</span><span>></span><span> {</span></span>
<span class=giallo-l><span class=z-comment>    //</span><span class=z-comment> If divide returns Err, calculate returns Err immediately</span></span>
<span class=giallo-l><span class=z-storage>    let</span><span class="z-variable z-other"> result</span><span class=z-keyword> =</span><span class="z-entity z-name z-function"> divide</span><span>(</span><span class="z-constant z-numeric">10</span><span>,</span><span class="z-constant z-numeric"> 0</span><span>)</span><span class=z-keyword>?</span><span>;</span><span> </span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span class="z-entity z-name z-type">    Ok</span><span>(</span><span class="z-variable z-other">result</span><span class=z-keyword> +</span><span class="z-constant z-numeric"> 100</span><span>)</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>fn</span><span class="z-entity z-name z-function"> main</span><span>(</span><span>)</span><span> {</span></span>
<span class=giallo-l><span class=z-comment>    //</span><span class=z-comment> Pattern match on the Result</span></span>
<span class=giallo-l><span class=z-keyword>    match</span><span class="z-entity z-name z-function"> calculate</span><span>(</span><span>)</span><span> {</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">        Ok</span><span>(</span><span class="z-variable z-other">val</span><span>)</span><span class=z-keyword> =></span><span class="z-entity z-name z-function"> println!</span><span>(</span><span class=z-string>"</span><span class=z-string>Result: </span><span class=z-string>{</span><span class=z-string>}</span><span class=z-string>"</span><span>,</span><span class="z-variable z-other"> val</span><span>)</span><span>,</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">        Err</span><span>(</span><span class="z-variable z-other">e</span><span>)</span><span class=z-keyword>  =></span><span class="z-entity z-name z-function"> println!</span><span>(</span><span class=z-string>"</span><span class=z-string>Error: </span><span class=z-string>{</span><span class=z-string>:?</span><span class=z-string>}</span><span class=z-string>"</span><span>,</span><span class="z-variable z-other"> e</span><span>)</span><span>,</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><p>The <code>?</code> operator propagates errors up, and makes code shorter, but it can also obscure control flow. The whole flow of the function can be interrupted by a single <code>?</code>. This single symbol rewires control flow and introduces implicit short-circuiting, which can obscure the data path. At least, the <code>?</code> operator is limited to functions returning <code>Result</code> or <code>Option</code>, so its use is explicit in the function signature.<p>This is a limited form of monadic error handling. This is arguably one of Rust’s strengths, it makes functional programming ideas more mainstream, e.g., algebraic data types, pattern matching, higher-order functions, and monadic error handling.<p>Of course, Rust doesn’t force you to propagate or handle errors safely — you can always opt out:<pre class="giallo z-code"><code data-lang=rust><span class=giallo-l><span class=z-storage>let</span><span class="z-variable z-other"> val</span><span class=z-keyword> =</span><span class="z-entity z-name z-function"> foo</span><span>(</span><span>)</span><span class=z-keyword>.</span><span class="z-entity z-name z-function">unwrap</span><span>(</span><span>)</span><span>;</span><span class=z-comment> //</span><span class=z-comment> panics if Err</span></span>
<span class=giallo-l><span class=z-storage>let</span><span class="z-variable z-other"> val</span><span class=z-keyword> =</span><span class="z-entity z-name z-function"> foo</span><span>(</span><span>)</span><span class=z-keyword>.</span><span class="z-entity z-name z-function">expect</span><span>(</span><span class=z-string>"</span><span class=z-string>better crash message</span><span class=z-string>"</span><span>)</span><span>;</span><span class=z-comment> //</span><span class=z-comment> same, but with context</span></span></code></pre><h3 id=a-monadic-digression>A Monadic Digression</h3><p>Before writing this document, I assumed that Rust’s <code>?</code> operator was limited to built-in types like <code>Result&lt;T, E></code> and <code>Option&lt;T></code>, effectively restricting its use to these specific monads. While this holds true on stable Rust, the nightly-only <code>try_trait_v2</code> feature extends the language’s capabilities by allowing custom types to participate in <code>?</code>-based control flow through the implementation of the <code>Try</code> and <code>FromResidual</code> traits.<pre class="giallo z-code"><code data-lang=rust><span class=giallo-l><span>#</span><span>!</span><span>[</span><span>feature</span><span>(</span><span>try_trait_v2</span><span>)</span><span>]</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>use</span><span class="z-entity z-name z-namespace"> std</span><span class=z-keyword>::</span><span class="z-entity z-name z-namespace">convert</span><span class=z-keyword>::</span><span class="z-entity z-name z-type">Infallible</span><span>;</span></span>
<span class=giallo-l><span class=z-keyword>use</span><span class="z-entity z-name z-namespace"> std</span><span class=z-keyword>::</span><span class="z-entity z-name z-namespace">ops</span><span class=z-keyword>::</span><span>{</span><span class="z-entity z-name z-type">ControlFlow</span><span>,</span><span class="z-entity z-name z-type"> FromResidual</span><span>,</span><span class="z-entity z-name z-type"> Try</span><span>}</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>#</span><span>[</span><span>derive</span><span>(</span><span class="z-entity z-name z-type">Debug</span><span>)</span><span>]</span></span>
<span class=giallo-l><span class=z-storage>enum</span><span class="z-entity z-name z-type"> MyResult</span><span>&lt;</span><span class="z-entity z-name z-type">T</span><span>,</span><span class="z-entity z-name z-type"> E</span><span>></span><span> {</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">    Ok</span><span>(</span><span class="z-entity z-name z-type">T</span><span>)</span><span>,</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">    Err</span><span>(</span><span class="z-entity z-name z-type">E</span><span>)</span><span>,</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>impl</span><span>&lt;</span><span class="z-entity z-name z-type">T</span><span>,</span><span class="z-entity z-name z-type"> E</span><span>></span><span class="z-entity z-name z-type"> Try</span><span class=z-keyword> for</span><span class="z-entity z-name z-type"> MyResult</span><span>&lt;</span><span class="z-entity z-name z-type">T</span><span>,</span><span class="z-entity z-name z-type"> E</span><span>></span><span> {</span></span>
<span class=giallo-l><span class=z-storage>    type</span><span class="z-entity z-name z-type"> Output</span><span class=z-keyword> =</span><span class="z-entity z-name z-type"> T</span><span>;</span></span>
<span class=giallo-l><span class=z-storage>    type</span><span class="z-entity z-name z-type"> Residual</span><span class=z-keyword> =</span><span class="z-entity z-name z-type"> MyResult</span><span>&lt;</span><span class="z-entity z-name z-type">Infallible</span><span>,</span><span class="z-entity z-name z-type"> E</span><span>></span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>    fn</span><span class="z-entity z-name z-function"> from_output</span><span>(</span><span class="z-variable z-other">output</span><span class=z-keyword>:</span><span class="z-entity z-name z-type"> T</span><span>)</span><span class=z-keyword> -></span><span class="z-variable z-language"> Self</span><span> {</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">        MyResult</span><span class=z-keyword>::</span><span class="z-entity z-name z-type">Ok</span><span>(</span><span class="z-variable z-other">output</span><span>)</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>    fn</span><span class="z-entity z-name z-function"> branch</span><span>(</span><span class="z-variable z-language">self</span><span>)</span><span class=z-keyword> -></span><span class="z-entity z-name z-type"> ControlFlow</span><span>&lt;</span><span class="z-variable z-language">Self</span><span class=z-keyword>::</span><span class="z-entity z-name z-type">Residual</span><span>,</span><span class="z-variable z-language"> Self</span><span class=z-keyword>::</span><span class="z-entity z-name z-type">Output</span><span>></span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>        match</span><span class="z-variable z-language"> self</span><span> {</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">            MyResult</span><span class=z-keyword>::</span><span class="z-entity z-name z-type">Ok</span><span>(</span><span class="z-variable z-other">val</span><span>)</span><span class=z-keyword> =></span><span> {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">                println!</span><span>(</span><span class=z-string>"</span><span class=z-string>Encountered Ok with value.</span><span class=z-string>"</span><span>)</span><span>;</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">                ControlFlow</span><span class=z-keyword>::</span><span class="z-entity z-name z-function">Continue</span><span>(</span><span class="z-variable z-other">val</span><span>)</span></span>
<span class=giallo-l><span>            }</span><span>,</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">            MyResult</span><span class=z-keyword>::</span><span class="z-entity z-name z-type">Err</span><span>(</span><span class="z-variable z-other">e</span><span>)</span><span class=z-keyword> =></span><span> {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">                println!</span><span>(</span><span class=z-string>"</span><span class=z-string>Encountered Err with value.</span><span class=z-string>"</span><span>)</span><span>;</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">                ControlFlow</span><span class=z-keyword>::</span><span class="z-entity z-name z-function">Break</span><span>(</span><span class="z-entity z-name z-namespace">MyResult</span><span class=z-keyword>::</span><span class="z-entity z-name z-type">Err</span><span>(</span><span class="z-variable z-other">e</span><span>)</span><span>)</span></span>
<span class=giallo-l><span>            }</span><span>,</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>impl</span><span>&lt;</span><span class="z-entity z-name z-type">T</span><span>,</span><span class="z-entity z-name z-type"> E</span><span>></span><span class="z-entity z-name z-type"> FromResidual</span><span>&lt;</span><span class="z-entity z-name z-type">MyResult</span><span>&lt;</span><span class="z-entity z-name z-type">Infallible</span><span>,</span><span class="z-entity z-name z-type"> E</span><span>></span><span>></span><span class=z-keyword> for</span><span class="z-entity z-name z-type"> MyResult</span><span>&lt;</span><span class="z-entity z-name z-type">T</span><span>,</span><span class="z-entity z-name z-type"> E</span><span>></span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>    fn</span><span class="z-entity z-name z-function"> from_residual</span><span>(</span><span class="z-variable z-other">residual</span><span class=z-keyword>:</span><span class="z-entity z-name z-type"> MyResult</span><span>&lt;</span><span class="z-entity z-name z-type">Infallible</span><span>,</span><span class="z-entity z-name z-type"> E</span><span>></span><span>)</span><span class=z-keyword> -></span><span class="z-variable z-language"> Self</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>        match</span><span class="z-variable z-other"> residual</span><span> {</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">            MyResult</span><span class=z-keyword>::</span><span class="z-entity z-name z-type">Err</span><span>(</span><span class="z-variable z-other">e</span><span>)</span><span class=z-keyword> =></span><span> {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">                println!</span><span>(</span><span class=z-string>"</span><span class=z-string>Converting residual Err to MyResult.</span><span class=z-string>"</span><span>)</span><span>;</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">                MyResult</span><span class=z-keyword>::</span><span class="z-entity z-name z-type">Err</span><span>(</span><span class="z-variable z-other">e</span><span>)</span></span>
<span class=giallo-l><span>            }</span><span>,</span></span>
<span class=giallo-l><span class="z-variable z-other">            _</span><span class=z-keyword> =></span><span class="z-entity z-name z-function"> unreachable!</span><span>(</span><span>)</span><span>,</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>fn</span><span class="z-entity z-name z-function"> do_something</span><span>(</span><span>)</span><span class=z-keyword> -></span><span class="z-entity z-name z-type"> MyResult</span><span>&lt;</span><span class="z-entity z-name z-type">i32</span><span>,</span><span class=z-keyword> &</span><span>'</span><span class="z-entity z-name z-type">static</span><span class="z-entity z-name z-type"> str</span><span>></span><span> {</span></span>
<span class=giallo-l><span class=z-storage>    let</span><span class="z-variable z-other"> x</span><span class=z-keyword> =</span><span class="z-entity z-name z-type"> MyResult</span><span class=z-keyword>::</span><span class="z-entity z-name z-type">Ok</span><span>(</span><span class="z-constant z-numeric">10</span><span>)</span><span class=z-keyword>?</span><span>;</span></span>
<span class=giallo-l><span class=z-storage>    let</span><span class="z-variable z-other"> y</span><span class=z-keyword>:</span><span class="z-entity z-name z-type"> i32</span><span class=z-keyword> =</span><span class="z-entity z-name z-type"> MyResult</span><span class=z-keyword>::</span><span class="z-entity z-name z-type">Err</span><span>(</span><span class=z-string>"</span><span class=z-string>oops</span><span class=z-string>"</span><span>)</span><span class=z-keyword>?</span><span>;</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">    MyResult</span><span class=z-keyword>::</span><span class="z-entity z-name z-type">Ok</span><span>(</span><span class="z-variable z-other">x</span><span class=z-keyword> +</span><span class="z-variable z-other"> y</span><span>)</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>fn</span><span class="z-entity z-name z-function"> main</span><span>(</span><span>)</span><span> {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    println!</span><span>(</span><span class=z-string>"</span><span class=z-string>Output: </span><span class=z-string>"</span><span>,</span><span class="z-entity z-name z-function"> do_something</span><span>(</span><span>)</span><span>)</span><span>;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span></code></pre><p>Outputs:<pre class="giallo z-code"><code data-lang=plain><span class=giallo-l><span>Encountered Ok with value.</span></span>
<span class=giallo-l><span>Encountered Err with value.</span></span>
<span class=giallo-l><span>Converting residual Err to MyResult.</span></span>
<span class=giallo-l><span>Output: Err("oops")</span></span></code></pre><p>In this implementation:<ul><li><code>from_output</code> is analogous to Haskell’s <code>return</code> (or <code>pure</code> in the applicative context), lifting a value into the monadic type.<li><code>branch</code> corresponds to the monadic bind (<code>>>=</code>), determining whether to propagate the value or short-circuit.<li><code>from_residual</code> is required for integrating with other <code>Try</code>-compatible types and enabling error propagation across type boundaries.</ul><p>Despite this flexibility, Rust’s <code>?</code> operator remains fundamentally tied to error-handling semantics. Unlike Haskell, where monads generalize sequencing of computations across various effects, Rust’s monadic ergonomics, through <code>?</code>, are constrained to types modelling control flow interruption.<p>Despite how tempting it might look to generalize <code>?</code> to arbitrary monads, I would caution against it. Unlike Haskell, where monads are a first-class abstraction for sequencing computations with various effects, using <code>?</code> with arbitrary monads could lead to confusion.<h2 id=a-monad-is-just-a-monoid-in-the-category-of-endofunctors-what-s-the-problem-haskell>A monad is just a monoid in the category of endofunctors, what’s the problem? (Haskell)</h2><p>Where Rust brings functional error handling into a systems programming language – with <code>Result&lt;T, E></code>, <code>Option&lt;T></code>, and <code>?</code> – Haskell has far more powerful abstractions.<p>Monads give you composable effects, including errors. You can throw, catch, pattern match, and compose computations in <code>Either</code>, <code>Maybe</code>, or more complex stacks using monad transformers.<p>As in Rust, <code>Either Error Value</code> encodes a computation that can fail. But in Haskell, you can manipulate it using the full suite of monadic tools.<p>The example below shows how <code>ExceptT</code>—a monad transformer—extends any base monad (typically <code>IO</code>) with error-handling capabilities. It generalizes the <code>Either e a</code> pattern, allowing you to compose error propagation with other effects (like <code>IO</code>, <code>State</code>, etc.).<pre class="giallo z-code"><code data-lang=haskell><span class=giallo-l><span class=z-keyword>import</span><span class="z-entity z-name z-namespace"> Control.Monad.Except</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>--</span><span class=z-comment> Define error type and a type alias for our error-handling monad</span></span>
<span class=giallo-l><span class=z-keyword>data</span><span class=z-storage> AppError</span></span>
<span class=giallo-l><span class=z-keyword>  =</span><span class="z-constant z-other"> DivideByZero</span></span>
<span class=giallo-l><span class=z-keyword>  |</span><span class="z-constant z-other"> UnexpectedError</span><span class=z-storage> String</span></span>
<span class=giallo-l><span class=z-keyword>  deriving</span><span> (</span><span class=z-storage>Show</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>type</span><span class=z-storage> AppM</span><span class=z-keyword> =</span><span class=z-storage> ExceptT</span><span class=z-storage> AppError</span><span class=z-storage> IO</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>--</span><span class=z-comment> A function that fails safely</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">safeDivide</span><span class=z-keyword> ::</span><span class=z-storage> Int</span><span class=z-keyword> -></span><span class=z-storage> Int</span><span class=z-keyword> -></span><span class=z-storage> AppM</span><span class=z-storage> Int</span></span>
<span class=giallo-l><span>safeDivide _ </span><span class="z-constant z-numeric">0</span><span class=z-keyword> =</span><span> throwError </span><span class="z-constant z-other">DivideByZero</span></span>
<span class=giallo-l><span>safeDivide x y</span></span>
<span class=giallo-l><span class=z-keyword>  |</span><span> y </span><span class=z-keyword>&lt;</span><span class="z-constant z-numeric"> 0</span><span class=z-keyword>     =</span><span> throwError </span><span>(</span><span class="z-constant z-other">UnexpectedError</span><span class=z-string> "</span><span class=z-string>Negative denominator</span><span class=z-string>"</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>  |</span><span> otherwise </span><span class=z-keyword>=</span><span> return </span><span>(</span><span>x </span><span class=z-keyword>`</span><span class=z-keyword>div</span><span class=z-keyword>`</span><span> y</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>--</span><span class=z-comment> Composed computation</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">compute</span><span class=z-keyword> ::</span><span class=z-storage> Int</span><span class=z-keyword> -></span><span class=z-storage> Int</span><span class=z-keyword> -></span><span class=z-storage> Int</span><span class=z-keyword> -></span><span class=z-storage> AppM</span><span class=z-storage> Int</span></span>
<span class=giallo-l><span>compute a b c </span><span class=z-keyword>=</span><span class=z-keyword> do</span></span>
<span class=giallo-l><span>  x </span><span class=z-keyword>&lt;-</span><span> safeDivide a b</span></span>
<span class=giallo-l><span>  y </span><span class=z-keyword>&lt;-</span><span> safeDivide x c</span></span>
<span class=giallo-l><span>  return y</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>--</span><span class=z-comment> Entry point</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">main</span><span class=z-keyword> ::</span><span class=z-storage> IO</span><span> (</span><span>)</span></span>
<span class=giallo-l><span>main </span><span class=z-keyword>=</span><span class=z-keyword> do</span></span>
<span class=giallo-l><span>  result </span><span class=z-keyword>&lt;-</span><span> runExceptT </span><span>(</span><span>compute </span><span class="z-constant z-numeric">10</span><span class="z-constant z-numeric"> 2</span><span class="z-constant z-numeric"> 0</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>  case</span><span> result </span><span class=z-keyword>of</span></span>
<span class=giallo-l><span class="z-constant z-other">    Left</span><span class="z-constant z-other"> DivideByZero</span><span class=z-keyword>           -></span><span> putStrLn </span><span class=z-string>"</span><span class=z-string>Error: division by zero</span><span class=z-string>"</span></span>
<span class=giallo-l><span class="z-constant z-other">    Left</span><span> (</span><span class="z-constant z-other">UnexpectedError</span><span> msg</span><span>)</span><span class=z-keyword>  -></span><span> putStrLn </span><span class=z-keyword>$</span><span class=z-string> "</span><span class=z-string>Unexpected error: </span><span class=z-string>"</span><span class=z-keyword> ++</span><span> msg</span></span>
<span class=giallo-l><span class="z-constant z-other">    Right</span><span> val                   </span><span class=z-keyword>-></span><span> putStrLn </span><span class=z-keyword>$</span><span class=z-string> "</span><span class=z-string>Success: </span><span class=z-string>"</span><span class=z-keyword> ++</span><span> show val</span></span></code></pre><p>This is elegant – you get typed, structured error handling that composes seamlessly with <code>IO</code>.<p>But once you start stacking more than one effect - say, <code>ReaderT</code>, <code>StateT</code>, and <code>ExceptT</code> – it quickly becomes hard to manage. Libraries like <code>mtl</code>, <code>freer</code>, or <code>polysemy</code> try to reduce this friction, but the conceptual weight remains high. The learning curve is steep, and yes, monads still confuse people. Not because they’re inherently difficult, but because most programming education doesn’t equip you to think in algebraic structures.<h3 id=excepting-monads>Excepting Monads</h3><p>Despite Haskell’s emphasis on pure functions and strong static typing, it still includes support for runtime exceptions. Why? Because not all errors fit cleanly into a type-level model—especially when dealing with I/O or legacy code. However, these exceptions can be safely and idiomatically captured and transformed into more composable types like <code>Either</code>, making them compatible with the broader functional ecosystem.<pre class="giallo z-code"><code data-lang=haskell><span class=giallo-l><span class=z-keyword>import</span><span class="z-entity z-name z-namespace"> Control.Exception</span><span> (</span><span class=z-storage>SomeException</span><span>,</span><span class="z-entity z-name z-function"> try</span><span>,</span><span class=z-storage> Exception</span><span>,</span><span class="z-entity z-name z-function"> throwIO</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>import</span><span class="z-entity z-name z-namespace"> Data.Typeable</span><span> (</span><span class=z-storage>Typeable</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>--</span><span class=z-comment> Example function that may fail at runtime</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">failingIO</span><span class=z-keyword> ::</span><span class=z-storage> IO</span><span class=z-storage> Int</span></span>
<span class=giallo-l><span>failingIO </span><span class=z-keyword>=</span><span> throwIO </span><span class=z-keyword>$</span><span> userError </span><span class=z-string>"</span><span class=z-string>Something went wrong</span><span class=z-string>"</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-entity z-name z-function">main</span><span class=z-keyword> ::</span><span class=z-storage> IO</span><span> (</span><span>)</span></span>
<span class=giallo-l><span>main </span><span class=z-keyword>=</span><span class=z-keyword> do</span></span>
<span class=giallo-l><span>  result </span><span class=z-keyword>&lt;-</span><span> try failingIO </span><span class=z-keyword>::</span><span class=z-storage> IO</span><span> (</span><span class=z-storage>Either</span><span class=z-storage> SomeException</span><span class=z-storage> Int</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>  case</span><span> result </span><span class=z-keyword>of</span></span>
<span class=giallo-l><span class="z-constant z-other">    Left</span><span> e  </span><span class=z-keyword>-></span><span> putStrLn </span><span class=z-keyword>$</span><span class=z-string> "</span><span class=z-string>Caught error: </span><span class=z-string>"</span><span class=z-keyword> ++</span><span> show e</span></span>
<span class=giallo-l><span class="z-constant z-other">    Right</span><span> v </span><span class=z-keyword>-></span><span> print v</span></span></code></pre><h3 id=parsing-and-non-empty-chains-scala>Parsing and Non-Empty Chains (Scala)</h3><p>This brings us to 2021, where this blog post really began. During my final undergraduate project with a company, we decided to step away from the mainstream and explore more functional tooling. That led us to Scala, and more specifically, to Cats.<p>In many real-world domains – especially parsing, validation, and data ingestion – you don’t just want to know <em>if</em> something failed. You want to know <em>everything</em> that failed.<p>Scala’s <code>Cats</code> library handles this elegantly with <code>Validated</code> and <code>NonEmptyChain</code>. Unlike <code>Either</code>, which short-circuits on the first failure, <code>Validated</code> accumulates all errors.<pre class="giallo z-code"><code data-lang=scala><span class=giallo-l><span class=z-keyword>import</span><span> cats</span><span>.</span><span>data</span><span>.</span><span>{</span><span class="z-entity z-name z-class">Validated</span><span>, </span><span class="z-entity z-name z-class">NonEmptyChain</span><span>}</span></span>
<span class=giallo-l><span class=z-keyword>import</span><span> cats</span><span>.</span><span>syntax</span><span>.</span><span>all</span><span>.</span><span>_</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//</span><span class=z-comment> Types</span></span>
<span class=giallo-l><span class=z-keyword>type</span><span class="z-entity z-name z-type"> Error</span><span class=z-keyword> =</span><span class="z-entity z-name z-class"> String</span></span>
<span class=giallo-l><span class=z-keyword>type</span><span class="z-entity z-name z-type"> Result</span><span>[</span><span class="z-entity z-name z-class">A</span><span>]</span><span class=z-keyword> =</span><span class="z-entity z-name z-class"> Validated</span><span>[</span><span class="z-entity z-name z-class">NonEmptyChain</span><span>[</span><span class="z-entity z-name z-class">Error</span><span>]</span><span>, </span><span class="z-entity z-name z-class">A</span><span>]</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//</span><span class=z-comment> Domain model</span></span>
<span class=giallo-l><span class=z-keyword>case</span><span class=z-keyword> class</span><span class="z-entity z-name z-class"> User</span><span>(</span><span>name</span><span>:</span><span class="z-entity z-name z-class"> String</span><span>, </span><span>email</span><span>:</span><span class="z-entity z-name z-class"> String</span><span>, </span><span>age</span><span>:</span><span class="z-entity z-name z-class"> Int</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//</span><span class=z-comment> Input model (e.g., raw user-submitted data)</span></span>
<span class=giallo-l><span class=z-keyword>case</span><span class=z-keyword> class</span><span class="z-entity z-name z-class"> RawInput</span><span>(</span><span>name</span><span>:</span><span class="z-entity z-name z-class"> String</span><span>, </span><span>email</span><span>:</span><span class="z-entity z-name z-class"> String</span><span>, </span><span>age</span><span>:</span><span class="z-entity z-name z-class"> String</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//</span><span class=z-comment> Validation functions</span></span>
<span class=giallo-l><span class=z-keyword>def</span><span class="z-entity z-name z-function"> validateName</span><span>(</span><span>name</span><span>:</span><span class="z-entity z-name z-class"> String</span><span>)</span><span class=z-keyword>:</span><span class="z-entity z-name z-class"> Result</span><span>[</span><span class="z-entity z-name z-class">String</span><span>]</span><span class=z-keyword> =</span></span>
<span class=giallo-l><span class=z-keyword>  if</span><span> (</span><span>name.trim.nonEmpty</span><span>)</span><span> name.validNec</span></span>
<span class=giallo-l><span class=z-keyword>  else</span><span class=z-string> "</span><span class=z-string>Name cannot be empty</span><span class=z-string>"</span><span>.invalidNec</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>def</span><span class="z-entity z-name z-function"> validateEmail</span><span>(</span><span>email</span><span>:</span><span class="z-entity z-name z-class"> String</span><span>)</span><span class=z-keyword>:</span><span class="z-entity z-name z-class"> Result</span><span>[</span><span class="z-entity z-name z-class">String</span><span>]</span><span class=z-keyword> =</span></span>
<span class=giallo-l><span class=z-keyword>  if</span><span> (</span><span>email.contains</span><span>(</span><span class=z-string>"</span><span class=z-string>@</span><span class=z-string>"</span><span>)</span><span>)</span><span> email.validNec</span></span>
<span class=giallo-l><span class=z-keyword>  else</span><span class=z-string> "</span><span class=z-string>Email must contain '@'</span><span class=z-string>"</span><span>.invalidNec</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>def</span><span class="z-entity z-name z-function"> validateAge</span><span>(</span><span>ageStr</span><span>:</span><span class="z-entity z-name z-class"> String</span><span>)</span><span class=z-keyword>:</span><span class="z-entity z-name z-class"> Result</span><span>[</span><span class="z-entity z-name z-class">Int</span><span>]</span><span class=z-keyword> =</span></span>
<span class=giallo-l><span>  ageStr.toIntOption </span><span class=z-keyword>match</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>    case</span><span class="z-entity z-name z-class"> Some</span><span>(</span><span>age</span><span>)</span><span class=z-keyword> if</span><span> age </span><span class=z-keyword>>=</span><span class="z-constant z-numeric"> 0</span><span class=z-keyword> =></span><span> age.validNec</span></span>
<span class=giallo-l><span class=z-keyword>    case</span><span class="z-entity z-name z-class"> Some</span><span>(</span><span>_</span><span>)</span><span class=z-keyword>               =></span><span class=z-string> "</span><span class=z-string>Age must be non-negative</span><span class=z-string>"</span><span>.invalidNec</span></span>
<span class=giallo-l><span class=z-keyword>    case</span><span class="z-entity z-name z-class"> None</span><span class=z-keyword>                  =></span><span class=z-string> "</span><span class=z-string>Age must be a valid number</span><span class=z-string>"</span><span>.invalidNec</span></span>
<span class=giallo-l><span>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//</span><span class=z-comment> Aggregate all validations</span></span>
<span class=giallo-l><span class=z-keyword>def</span><span class="z-entity z-name z-function"> validateUser</span><span>(</span><span>input</span><span>:</span><span class="z-entity z-name z-class"> RawInput</span><span>)</span><span class=z-keyword>:</span><span class="z-entity z-name z-class"> Result</span><span>[</span><span class="z-entity z-name z-class">User</span><span>]</span><span class=z-keyword> =</span></span>
<span class=giallo-l><span>  (</span></span>
<span class=giallo-l><span>    validateName</span><span>(</span><span>input.name</span><span>)</span><span>,</span></span>
<span class=giallo-l><span>    validateEmail</span><span>(</span><span>input.email</span><span>)</span><span>,</span></span>
<span class=giallo-l><span>    validateAge</span><span>(</span><span>input.age</span><span>)</span></span>
<span class=giallo-l><span>  )</span><span>.mapN</span><span>(</span><span class="z-entity z-name z-class">User</span><span>.apply</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>@</span><span>main </span><span class=z-keyword>def</span><span class="z-entity z-name z-function"> runValidation</span><span>()</span><span class=z-keyword>:</span><span class="z-entity z-name z-class"> Unit</span><span class=z-keyword> =</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>  val</span><span> goodInput</span><span class=z-keyword> =</span><span class="z-entity z-name z-class"> RawInput</span><span>(</span><span class=z-string>"</span><span class=z-string>Alice</span><span class=z-string>"</span><span>, </span><span class=z-string>"</span><span class=z-string>alice@example.com</span><span class=z-string>"</span><span>, </span><span class=z-string>"</span><span class=z-string>30</span><span class=z-string>"</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>  val</span><span> badInput</span><span class=z-keyword>  =</span><span class="z-entity z-name z-class"> RawInput</span><span>(</span><span class=z-string>"</span><span class=z-string>"</span><span>, </span><span class=z-string>"</span><span class=z-string>no-at-symbol</span><span class=z-string>"</span><span>, </span><span class=z-string>"</span><span class=z-string>-5</span><span class=z-string>"</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>  println</span><span>(</span><span class=z-string>"</span><span class=z-string>Valid input result:</span><span class=z-string>"</span><span>)</span></span>
<span class=giallo-l><span>  println</span><span>(</span><span>validateUser</span><span>(</span><span>goodInput</span><span>)</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>  println</span><span>(</span><span class=z-string>"</span><span class="z-constant z-character">\n</span><span class=z-string>Invalid input result:</span><span class=z-string>"</span><span>)</span></span>
<span class=giallo-l><span>  println</span><span>(</span><span>validateUser</span><span>(</span><span>badInput</span><span>)</span><span>)</span></span>
<span class=giallo-l><span>}</span></span></code></pre><p>Outputs:<pre class="giallo z-code"><code data-lang=plain><span class=giallo-l><span>Valid input result:</span></span>
<span class=giallo-l><span>Valid(User(Alice,alice@example.com,30))</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>Invalid input result:</span></span>
<span class=giallo-l><span>Invalid(Chain(Name cannot be empty, Email must contain '@', Age must be non-negative))</span></span></code></pre><p>If name and email both fail, you get both errors, not just the first. That’s the kind of robustness you want in real-world parsing, form validation, or config loading. And all that without much boilerplate code.<p>It is important to note, though, that <code>Validated</code> <a class=external href=https://typelevel.org/cats/datatypes/validated.html#of-flatmaps-and-eithers target=_blank>is not a monad</a> due to the accumulation of errors.<h2 id=effect-systems-haskell>Effect Systems (Haskell++)</h2><p>Effect systems bring to error handling – and to side effects more broadly – more powerful tools. Rather than wrapping all effects in a monad like <code>IO</code>, these systems explicitly track them in the type signature. This means you can determine exactly which effects a function might perform (I/O, logging, error handling, state, etc.) directly from its type – not by convention, but enforced by the compiler.<p>The <a class=external href=https://hackage.haskell.org/package/polysemy target=_blank>polysemy</a> library in Haskell is a good example of such a system. Here’s a simple example extracted from <a class=external href=https://github.com/willGuimont/exercises_api target=_blank>willGuimont/exercises_api</a>. It combines state, logging, and error handling, all visible in the type signature.<pre class="giallo z-code"><code data-lang=haskell><span class=giallo-l><span class=z-comment>--</span><span class=z-comment> Error type</span></span>
<span class=giallo-l><span class=z-keyword>data</span><span class=z-storage> ExerciseError</span></span>
<span class=giallo-l><span class=z-keyword>  =</span><span class="z-constant z-other"> ExerciseNotFound</span><span class=z-storage> ExerciseId</span></span>
<span class=giallo-l><span class=z-comment>  --</span><span class=z-comment> And other types of errors...</span></span>
<span class=giallo-l><span class=z-keyword>  deriving</span><span> (</span><span class=z-storage>Show</span><span>,</span><span class=z-storage> Eq</span><span>,</span><span class=z-storage> Generic</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>--</span><span class=z-comment> Persistence effect to query exercices</span></span>
<span class=giallo-l><span class=z-keyword>data</span><span class=z-storage> Persistence</span><span class="z-variable z-other"> m</span><span class="z-variable z-other"> a</span><span class=z-keyword> where</span></span>
<span class=giallo-l><span class=z-comment>  --</span><span class=z-comment> Exercise</span></span>
<span class=giallo-l><span class="z-constant z-other">  GetExerciseById</span><span class=z-keyword> ::</span><span class=z-storage> ExerciseId</span><span class=z-keyword> -></span><span class=z-storage> Persistence</span><span class="z-variable z-other"> m</span><span> (</span><span class=z-storage>Maybe</span><span class=z-storage> Exercise</span><span>)</span></span>
<span class=giallo-l><span class=z-comment>  --</span><span class=z-comment> And other effects...</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>makeSem ''Persistence</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-entity z-name z-function">runPersistenceOnIO</span><span class=z-keyword> ::</span><span> (</span><span class=z-storage>Member</span><span> (</span><span class=z-storage>Embed</span><span class=z-storage> IO</span><span>)</span><span class="z-variable z-other"> r</span><span>)</span><span class=z-keyword> =></span><span class=z-storage> Sem</span><span> (</span><span class=z-storage>Persistence</span><span class=z-keyword> '</span><span class=z-storage>:</span><span class="z-variable z-other"> r</span><span>)</span><span class="z-variable z-other"> a</span><span class=z-keyword> -></span><span class=z-storage> Sem</span><span class="z-variable z-other"> r</span><span class="z-variable z-other"> a</span></span>
<span class=giallo-l><span>runPersistenceOnIO </span><span class=z-keyword>=</span></span>
<span class=giallo-l><span>  interpret </span><span class=z-keyword>$</span></span>
<span class=giallo-l><span class=z-keyword>    \</span><span class=z-keyword>case</span></span>
<span class=giallo-l><span class=z-comment>      --</span><span class=z-comment> Exercise</span></span>
<span class=giallo-l><span class="z-constant z-other">      GetExerciseById</span><span> eId </span><span class=z-keyword>-></span><span> embed </span><span class=z-keyword>@</span><span class=z-storage>IO</span><span class=z-keyword> .</span><span> runSqlite sqliteDbName </span><span class=z-keyword>$</span><span class=z-keyword> do</span></span>
<span class=giallo-l><span class=z-keyword>        let</span><span> key </span><span class=z-keyword>=</span><span> toSqlKey eId </span><span class=z-keyword>::</span><span class=z-storage> DbExerciseId</span></span>
<span class=giallo-l><span>        eDb </span><span class=z-keyword>&lt;-</span><span> getEntity key</span></span>
<span class=giallo-l><span>        pure </span><span class=z-keyword>$</span><span> toExercise </span><span class=z-keyword>&lt;$></span><span> eDb</span></span>
<span class=giallo-l><span class=z-comment>    --</span><span class=z-comment> and others...</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>--</span><span class=z-comment> Example function using persistence</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">getExercise</span><span class=z-keyword> ::</span><span class=z-storage> Members</span><span> [</span><span class=z-storage>Persistence</span><span>,</span><span class=z-storage> Logging</span><span>,</span><span class=z-storage> Error</span><span class=z-storage> ExerciseError</span><span>]</span><span class="z-variable z-other"> r</span><span class=z-keyword> =></span><span class=z-storage> ExerciseId</span><span class=z-keyword> -></span><span class=z-storage> Sem</span><span class="z-variable z-other"> r</span><span class=z-storage> Exercise</span></span>
<span class=giallo-l><span>getExercise eId </span><span class=z-keyword>=</span><span class=z-keyword> do</span></span>
<span class=giallo-l><span>  logInfo </span><span class=z-string>"</span><span class=z-string>getExercise</span><span class=z-string>"</span></span>
<span class=giallo-l><span>  getExerciseById eId </span><span class=z-keyword>>>=</span><span class=z-keyword> \</span><span class=z-keyword>case</span></span>
<span class=giallo-l><span class="z-constant z-other">    Nothing</span><span class=z-keyword> -></span><span> throw </span><span class=z-keyword>$</span><span class="z-constant z-other"> ExerciseNotFound</span><span> eId </span><span class=z-comment>--</span><span class=z-comment> Error if the exercise is not found</span></span>
<span class=giallo-l><span class="z-constant z-other">    Just</span><span> e </span><span class=z-keyword>-></span><span> pure e</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>--</span><span class=z-comment> Server</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">formatNotFoundError</span><span class=z-keyword> ::</span><span class=z-storage> Show</span><span class="z-variable z-other"> a</span><span class=z-keyword> =></span><span class="z-entity z-name z-namespace"> BLU.</span><span class=z-storage>ByteString</span><span class=z-keyword> -></span><span class="z-variable z-other"> a</span><span class=z-keyword> -></span><span class=z-storage> Either</span><span class=z-storage> ServerError</span><span class="z-variable z-other"> b</span></span>
<span class=giallo-l><span>formatNotFoundError entityType eId  </span><span class=z-keyword>=</span><span class="z-constant z-other"> Left</span><span> err404 </span><span>{</span><span class="z-variable z-other">errBody</span><span class=z-keyword> =</span><span class="z-entity z-name z-namespace"> LBS.</span><span>concat </span><span>[</span><span>entityType </span><span class=z-keyword>&lt;></span><span class=z-string> "</span><span class=z-string> "</span><span>,</span><span class="z-entity z-name z-namespace"> BLU.</span><span>fromString </span><span class=z-keyword>$</span><span> show eId</span><span>,</span><span class=z-string> "</span><span class=z-string> does not exist</span><span class=z-string>"</span><span>]</span><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-entity z-name z-function">createApp</span><span class=z-keyword> ::</span><span class=z-storage> IO</span><span class=z-storage> Application</span></span>
<span class=giallo-l><span>createApp </span><span class=z-keyword>=</span><span class=z-keyword> do</span></span>
<span class=giallo-l><span>  loggerStdout </span><span class=z-keyword>&lt;-</span><span> fst </span><span class=z-keyword>&lt;$></span><span> newFastLogger </span><span>(</span><span class="z-constant z-other">LogStdout</span><span> defaultBufSize</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>  _ </span><span class=z-keyword>&lt;-</span><span> runM </span><span class=z-keyword>$</span><span> runPersistenceManagingOnIO executeMigration</span></span>
<span class=giallo-l><span>  _ </span><span class=z-keyword>&lt;-</span><span> runM </span><span class=z-keyword>$</span><span> runLoggingOnLogger loggerStdout </span><span class=z-keyword>.</span><span> logInfo </span><span class=z-keyword>$</span><span class=z-string> "</span><span class=z-string>Starting server on port </span><span class=z-string>"</span><span class=z-keyword> &lt;></span><span> pack </span><span>(</span><span>show port</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>  return </span><span>(</span><span>serve exerciseApi </span><span class=z-keyword>$</span><span> hoistServer exerciseApi </span><span>(</span><span class=z-keyword>`</span><span class=z-keyword>interpretServer</span><span class=z-keyword>`</span><span> loggerStdout</span><span>)</span><span> server</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>  where</span></span>
<span class=giallo-l><span>    interpretServer sem loggerStdout </span><span class=z-keyword>=</span></span>
<span class=giallo-l><span>      sem</span></span>
<span class=giallo-l><span class=z-keyword>        &</span><span> runPersistenceOnIO</span></span>
<span class=giallo-l><span class=z-keyword>        &</span><span> runLoggingOnLogger loggerStdout</span></span>
<span class=giallo-l><span class=z-keyword>        &</span><span> runError </span><span class=z-keyword>@</span><span class=z-storage>ExerciseError</span><span class=z-comment> --</span><span class=z-comment> Transforms thrown ExerciceError into Either ExerciseError a</span></span>
<span class=giallo-l><span class=z-keyword>        &</span><span> runM</span></span>
<span class=giallo-l><span class=z-keyword>        &</span><span> exerciseErrorHandler</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>    --</span><span class=z-comment> Convert Either ExerciseError a into a Servant error</span></span>
<span class=giallo-l><span>    exerciseErrorHandler </span><span class=z-keyword>=</span><span class="z-constant z-other"> Handler</span><span class=z-keyword> .</span><span class="z-constant z-other"> ExceptT</span><span class=z-keyword> .</span><span> fmap handleExerciseErrors</span></span>
<span class=giallo-l><span>    handleExerciseErrors </span><span>(</span><span class="z-constant z-other">Left</span><span> (</span><span class="z-constant z-other">ExerciseNotFound</span><span> eId</span><span>)</span><span>)</span><span class=z-keyword> =</span><span> formatNotFoundError </span><span class=z-string>"</span><span class=z-string>Exercise</span><span class=z-string>"</span><span> eId</span></span>
<span class=giallo-l><span class=z-comment>    --</span><span class=z-comment> and other errors</span></span>
<span class=giallo-l><span>    handleExerciseErrors </span><span>(</span><span class="z-constant z-other">Right</span><span> value</span><span>)</span><span class=z-keyword> =</span><span class="z-constant z-other"> Right</span><span> value</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-entity z-name z-function">port</span><span class=z-keyword> ::</span><span class=z-storage> Port</span></span>
<span class=giallo-l><span>port </span><span class=z-keyword>=</span><span class="z-constant z-numeric"> 8080</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-entity z-name z-function">startServer</span><span class=z-keyword> ::</span><span class=z-storage> IO</span><span> (</span><span>)</span></span>
<span class=giallo-l><span>startServer </span><span class=z-keyword>=</span><span class=z-keyword> do</span></span>
<span class=giallo-l><span>  app </span><span class=z-keyword>&lt;-</span><span> createApp</span></span>
<span class=giallo-l><span>  withStdoutLogger </span><span class=z-keyword>$</span><span class=z-keyword> \</span><span>appLogger </span><span class=z-keyword>-></span><span class=z-keyword> do</span></span>
<span class=giallo-l><span class=z-keyword>    let</span><span> settings </span><span class=z-keyword>=</span><span> setPort port </span><span class=z-keyword>$</span><span> setLogger appLogger defaultSettings</span></span>
<span class=giallo-l><span>    runSettings settings </span><span class=z-keyword>$</span><span> simpleCors app</span></span></code></pre><p>This makes exception handling more explicit and modular – you can define and run separate interpreters for each type of error, allowing each subsystem to handle its own failures independently.<p>This approach tickles my functional programming itch, but it comes with complexity. It is very elegant of thinking of your program as a series of composable effects, that are then interpreted at the edges of your system. More complex operations can be decomposed into smaller effects, before being interpreter. In some ways, it feels like a sort of interpreter that compiles your source code into a simpler bytecode (core language primitive operations) that is then executed. However, the learning curve is steep, and the abstraction overhead can be significant for small to medium projects.<h2 id=trust-but-verify-assert-d>Trust, but <del>verify</del> <code>assert</code> (D)</h2><p>Some languages, like Eiffel and D, support design by contract, a declarative way to specify preconditions, postconditions, and invariants. If a contract is violated, the program crashes or throws, often with minimal recovery. They are often even omitted when compiled in release mode. Thus, they are not, as the other techniques overviewed in this document, ways to validate user input or alternatives to exceptions.<p>Design by contract is about catching programmer mistakes, not handling external failures. If a function says “I expect a non-empty list,” and you give it an empty one, that’s not a runtime error to recover from – it’s a logic bug. The contract makes that explicit.<p>In contrast, exceptions, <code>Either</code>, <code>Result</code>, and <code>Validated</code> are about handling real-world uncertainty: invalid input, missing files, network timeouts, and corrupted data. These are expected failures that your program should handle gracefully.<p>Here’s a simple example of contract programming using D:<pre class="giallo z-code"><code data-lang=d><span class=giallo-l><span class=z-keyword>import</span><span> std.stdio</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-storage>struct</span><span class="z-entity z-name z-type"> BankAccount</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>    private</span><span> {</span></span>
<span class=giallo-l><span class=z-storage>        string</span><span> owner</span><span>;</span></span>
<span class=giallo-l><span class=z-storage>        double</span><span> balance</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-entity z-name z-function">    this</span><span>(</span><span class=z-storage>string</span><span> owner</span><span class=z-keyword>,</span><span class=z-storage> double</span><span> initialDeposit</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>    in</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>        assert(</span><span>owner.length</span><span class=z-keyword> ></span><span class="z-constant z-numeric"> 0</span><span class=z-keyword>,</span><span class=z-string> "</span><span class=z-string>Owner name cannot be empty</span><span class=z-string>.</span><span class=z-string>"</span><span class=z-keyword>)</span><span>;</span></span>
<span class=giallo-l><span class=z-keyword>        assert(</span><span>initialDeposit</span><span class=z-keyword> >=</span><span class="z-constant z-numeric"> 0</span><span class=z-keyword>,</span><span class=z-string> "</span><span class=z-string>Initial deposit must be non</span><span class=z-string>-</span><span class=z-string>negative</span><span class=z-string>.</span><span class=z-string>"</span><span class=z-keyword>)</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span class=z-keyword>    do</span><span> {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        this</span><span>.owner</span><span class=z-keyword> =</span><span> owner</span><span>;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        this</span><span>.balance</span><span class=z-keyword> =</span><span> initialDeposit</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-entity z-name z-class">    invariant()</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>        assert(</span><span>balance</span><span class=z-keyword> >=</span><span class="z-constant z-numeric"> 0</span><span class=z-keyword>,</span><span class=z-string> "</span><span class=z-string>Invariant failed</span><span class=z-string>:</span><span class=z-string> balance must be non</span><span class=z-string>-</span><span class=z-string>negative</span><span class=z-string>.</span><span class=z-string>"</span><span class=z-keyword>)</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-storage>    void</span><span class="z-entity z-name z-function"> deposit</span><span>(</span><span class=z-storage>double</span><span> amount</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>    in</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>        assert(</span><span>amount</span><span class=z-keyword> ></span><span class="z-constant z-numeric"> 0</span><span class=z-keyword>,</span><span class=z-string> "</span><span class=z-string>Deposit amount must be positive</span><span class=z-string>.</span><span class=z-string>"</span><span class=z-keyword>)</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span class=z-keyword>    do</span><span> {</span></span>
<span class=giallo-l><span class=z-storage>        double</span><span> oldBalance</span><span class=z-keyword> =</span><span> balance</span><span>;</span></span>
<span class=giallo-l><span>        balance</span><span class=z-keyword> +=</span><span> amount</span><span>;</span></span>
<span class=giallo-l><span class=z-keyword>        assert(</span><span>balance</span><span class=z-keyword> >=</span><span> oldBalance</span><span class=z-keyword>,</span><span class=z-string> "</span><span class=z-string>Postcondition failed</span><span class=z-string>:</span><span class=z-string> balance didn</span><span class=z-string>'</span><span class=z-string>t increase</span><span class=z-string>.</span><span class=z-string>"</span><span class=z-keyword>)</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-storage>    void</span><span class="z-entity z-name z-function"> withdraw</span><span>(</span><span class=z-storage>double</span><span> amount</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>    in</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>        assert(</span><span>amount</span><span class=z-keyword> ></span><span class="z-constant z-numeric"> 0</span><span class=z-keyword>,</span><span class=z-string> "</span><span class=z-string>Withdrawal amount must be positive</span><span class=z-string>.</span><span class=z-string>"</span><span class=z-keyword>)</span><span>;</span></span>
<span class=giallo-l><span class=z-keyword>        assert(</span><span>amount</span><span class=z-keyword> &lt;=</span><span> balance</span><span class=z-keyword>,</span><span class=z-string> "</span><span class=z-string>Insufficient funds</span><span class=z-string>.</span><span class=z-string>"</span><span class=z-keyword>)</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span class=z-keyword>    do</span><span> {</span></span>
<span class=giallo-l><span class=z-storage>        double</span><span> oldBalance</span><span class=z-keyword> =</span><span> balance</span><span>;</span></span>
<span class=giallo-l><span>        balance</span><span class=z-keyword> -=</span><span> amount</span><span>;</span></span>
<span class=giallo-l><span class=z-keyword>        assert(</span><span>balance</span><span class=z-keyword> &lt;=</span><span> oldBalance</span><span class=z-keyword>,</span><span class=z-string> "</span><span class=z-string>Postcondition failed</span><span class=z-string>:</span><span class=z-string> balance didn</span><span class=z-string>'</span><span class=z-string>t decrease</span><span class=z-string>.</span><span class=z-string>"</span><span class=z-keyword>)</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-storage>    double</span><span class="z-entity z-name z-function"> getBalance</span><span>(</span><span>)</span><span class=z-storage> const</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>        return</span><span> balance</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-storage>    string</span><span class="z-entity z-name z-function"> getOwner</span><span>(</span><span>)</span><span class=z-storage> const</span><span> {</span></span>
<span class=giallo-l><span class=z-keyword>        return</span><span> owner</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-storage>void</span><span class="z-entity z-name z-function"> main</span><span>(</span><span>)</span><span> {</span></span>
<span class=giallo-l><span class=z-storage>    auto</span><span> acc</span><span class=z-keyword> =</span><span class="z-entity z-name z-function"> BankAccount</span><span>(</span><span class=z-string>"</span><span class=z-string>Alice</span><span class=z-string>"</span><span class=z-keyword>,</span><span class="z-constant z-numeric"> 1000.0</span><span>)</span><span>;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    acc.deposit</span><span>(</span><span class="z-constant z-numeric">500.0</span><span>)</span><span>;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    acc.withdraw</span><span>(</span><span class="z-constant z-numeric">200.0</span><span>)</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-entity z-name z-function">    writeln</span><span>(</span><span class=z-string>"</span><span class=z-string>Owner</span><span class=z-string>:</span><span class=z-string> "</span><span class=z-keyword>,</span><span class="z-entity z-name z-function"> acc.getOwner</span><span>(</span><span>)</span><span>)</span><span>;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    writeln</span><span>(</span><span class=z-string>"</span><span class=z-string>Balance</span><span class=z-string>:</span><span class=z-string> "</span><span class=z-keyword>,</span><span class="z-entity z-name z-function"> acc.getBalance</span><span>(</span><span>)</span><span>)</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>    // Uncomment to test contract violations</span></span>
<span class=giallo-l><span class=z-comment>    // acc.withdraw(2000); // Insufficient funds</span></span>
<span class=giallo-l><span class=z-comment>    // acc.deposit(-100);  // Negative deposit</span></span>
<span class=giallo-l><span class=z-comment>    // auto bad = BankAccount("", -10); // Invalid initial values</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span></code></pre><p>Contracts in D – namely <code>in</code>, <code>out</code>, and <code>invariant</code> blocks - act like free unit tests embedded directly within your code. They document and verify the intended behaviour of functions and invariants of types, automatically checked at runtime in debug builds. For instance, a precondition on <code>withdraw</code> guarantees that the withdrawal amount is valid before the function runs, while a postcondition ensures the balance decreases. Unlike traditional unit tests, which are often separate and may omit corner cases, contracts enforce correctness systematically and immediately during development, catching logic errors as soon as they are introduced. They don’t replace unit tests entirely, but they eliminate many boilerplate checks, serving as a robust safety net and specification tool during implementation.<h2 id=let-it-go-crash-elixir>Let It <del>Go</del> Crash (Elixir)</h2><p>Elixir (and its Erlang foundations) embraces a fundamentally different philosophy: don’t prevent all errors - expect them, isolate them, and recover from them.<p>Instead of striving for defensive, error-free code at every level, Elixir leverages lightweight, isolated processes and robust supervision trees. Each process operates independently. When a failure occurs, it doesn’t propagate through shared memory or unwind a global stack. The process simply crashes – and a supervisor decides what to do next.<p>Here, errors are also values, represented as tagged tuples <code>{:ok, value}</code> and <code>{:error, reason}</code>. Functions return these tuples, and you pattern match on them to handle success and failure cases explicitly.<pre class="giallo z-code"><code data-lang=elixir><span class=giallo-l><span class=z-keyword>case</span><span class="z-entity z-name z-function"> do_something</span><span>(</span><span>)</span><span class=z-keyword> do</span></span>
<span class=giallo-l><span>  {</span><span class="z-constant z-other">:</span><span class="z-constant z-other">ok</span><span>,</span><span> result</span><span>}</span><span class=z-keyword> -></span><span> </span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    next_step</span><span>(</span><span>result</span><span>)</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span>  {</span><span class="z-constant z-other">:</span><span class="z-constant z-other">error</span><span>,</span><span> reason</span><span>}</span><span class=z-keyword> -></span><span> </span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    handle</span><span>(</span><span>reason</span><span>)</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span class=z-comment>  _</span><span class=z-keyword> -></span><span> </span></span>
<span class=giallo-l><span class=z-comment>    #</span><span class=z-comment> Catch-all for any other return value</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">    IO</span><span>.</span><span class="z-entity z-name z-function">puts</span><span>(</span><span class=z-string>"</span><span class=z-string>Unexpected result</span><span class=z-string>"</span><span>)</span></span>
<span class=giallo-l><span class=z-keyword>end</span></span></code></pre><p>This design makes fault tolerance an architectural feature, not an implementation detail. Pattern matching ensures that error handling remains explicit and readable. Elixir’s paradigm forces you to think about the not-so-happy path from the beginning. Every function that returns <code>:ok</code> or <code>:error</code> reminds you that failure is part of the domain. You can’t ignore it – you have to model it.<p>Unlike Go, where the programmer is responsible for inspecting and propagating every error manually, Elixir encourages you to crash early and let the system self-heal. Resilience is not patched in – it’s built in.<h2 id=conclusion-errors-are-the-norm-not-the-exception>Conclusion: Errors Are the Norm, Not the Exception</h2><p>There is no perfect model. But there are better tradeoffs.<p>Every meaningful computation—every I/O operation, API call, database query – can fail. Yet most programming languages treat error handling as a second-class concern: either overly verbose, dangerously ignorable, or both. The happy path is (almost) always easy to write. The hard part is everything else.<p>There’s <a class=external href=https://worrydream.com/refs/Brooks_1986_-_No_Silver_Bullet.pdf target=_blank>no silver bullet</a>. But there are better tradeoffs – depending on your constraints, goals, and team culture. Personally, my thoughts on error handling have evolved over time. In the past, I leaned towards leveraging the type system to make errors explicit, like Haskell and Rust. But lately, I’ve come to appreciate the simplicity of Odin’s approach, which balances explicitness with conciseness and Elixir’s philosophy of embracing failure as a first-class concern rather than defensive coding.<p>Errors are the norm, not the exception. The best systems are those that make handling them not only simple, but obvious.</article><hr><nav id=post-nav><a class="post-nav-item post-nav-prev" href=https://willguimont.com/blog/dumb2bar-re/> <div class=nav-arrow>Previous</div> <span class=post-title>Turn Your Dumbbells Into Barbell Plates</span> </a><a class="post-nav-item post-nav-next" href=https://willguimont.com/blog/random-photos/> <div class=nav-arrow>Next</div> <span class=post-title>Random Photos I found on my Hard Drive</span> </a></nav></main><footer id=site-footer><p>© wigum::website, 2026<ul id=external-links><li><a rel=" me" href=https://github.com/willGuimont title=GitHub> <i class=icon style=--icon:url(data:image/svg+xml,%3Csvg%20role%3D%27img%27%20viewBox%3D%270%200%2024%2024%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%3Ctitle%3EGitHub%3C%2Ftitle%3E%3Cpath%20d%3D%27M12%20.297c-6.63%200-12%205.373-12%2012%200%205.303%203.438%209.8%208.205%2011.385.6.113.82-.258.82-.577%200-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422%2018.07%203.633%2017.7%203.633%2017.7c-1.087-.744.084-.729.084-.729%201.205.084%201.838%201.236%201.838%201.236%201.07%201.835%202.809%201.305%203.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93%200-1.31.465-2.38%201.235-3.22-.135-.303-.54-1.523.105-3.176%200%200%201.005-.322%203.3%201.23.96-.267%201.98-.399%203-.405%201.02.006%202.04.138%203%20.405%202.28-1.552%203.285-1.23%203.285-1.23.645%201.653.24%202.873.12%203.176.765.84%201.23%201.91%201.23%203.22%200%204.61-2.805%205.625-5.475%205.92.42.36.81%201.096.81%202.22%200%201.606-.015%202.896-.015%203.286%200%20.315.21.69.825.57C20.565%2022.092%2024%2017.592%2024%2012.297c0-6.627-5.373-12-12-12%27%2F%3E%3C%2Fsvg%3E)></i> <span>GitHub</span> </a><li><a rel=" me" href=https://bsky.app/profile/willguimont.bsky.social title=Bluesky> <i class=icon style=--icon:url(data:image/svg+xml,%3Csvg%20role%3D%27img%27%20viewBox%3D%270%200%20600%20530%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%3Cpath%20d%3D%27m135.72%2044.03c66.496%2049.921%20138.02%20151.14%20164.28%20205.46%2026.262-54.316%2097.782-155.54%20164.28-205.46%2047.98-36.021%20125.72-63.892%20125.72%2024.795%200%2017.712-10.155%20148.79-16.111%20170.07-20.703%2073.984-96.144%2092.854-163.25%2081.433%20117.3%2019.964%20147.14%2086.092%2082.697%20152.22-122.39%20125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937%200.51669-3.7077%207.8964-13.714%2040.255-67.233%20197.36-189.63%2071.766-64.444-66.128-34.605-132.26%2082.697-152.22-67.108%2011.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07%200-88.687%2077.742-60.816%20125.72-24.795z%27%20fill%3D%27%231185fe%27%2F%3E%3C%2Fsvg%3E)></i> <span>Bluesky</span> </a><li><a rel=" me" href=https://instagram.com/wilguimont title=Instagram> <i class=icon style=--icon:url(data:image/svg+xml,%3Csvg%20role%3D%27img%27%20viewBox%3D%270%200%2024%2024%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%3Ctitle%3EInstagram%3C%2Ftitle%3E%3Cpath%20d%3D%27M7.0301.084c-1.2768.0602-2.1487.264-2.911.5634-.7888.3075-1.4575.72-2.1228%201.3877-.6652.6677-1.075%201.3368-1.3802%202.127-.2954.7638-.4956%201.6365-.552%202.914-.0564%201.2775-.0689%201.6882-.0626%204.947.0062%203.2586.0206%203.6671.0825%204.9473.061%201.2765.264%202.1482.5635%202.9107.308.7889.72%201.4573%201.388%202.1228.6679.6655%201.3365%201.0743%202.1285%201.38.7632.295%201.6361.4961%202.9134.552%201.2773.056%201.6884.069%204.9462.0627%203.2578-.0062%203.668-.0207%204.9478-.0814%201.28-.0607%202.147-.2652%202.9098-.5633.7889-.3086%201.4578-.72%202.1228-1.3881.665-.6682%201.0745-1.3378%201.3795-2.1284.2957-.7632.4966-1.636.552-2.9124.056-1.2809.0692-1.6898.063-4.948-.0063-3.2583-.021-3.6668-.0817-4.9465-.0607-1.2797-.264-2.1487-.5633-2.9117-.3084-.7889-.72-1.4568-1.3876-2.1228C21.2982%201.33%2020.628.9208%2019.8378.6165%2019.074.321%2018.2017.1197%2016.9244.0645%2015.6471.0093%2015.236-.005%2011.977.0014%208.718.0076%208.31.0215%207.0301.0839m.1402%2021.6932c-1.17-.0509-1.8053-.2453-2.2287-.408-.5606-.216-.96-.4771-1.3819-.895-.422-.4178-.6811-.8186-.9-1.378-.1644-.4234-.3624-1.058-.4171-2.228-.0595-1.2645-.072-1.6442-.079-4.848-.007-3.2037.0053-3.583.0607-4.848.05-1.169.2456-1.805.408-2.2282.216-.5613.4762-.96.895-1.3816.4188-.4217.8184-.6814%201.3783-.9003.423-.1651%201.0575-.3614%202.227-.4171%201.2655-.06%201.6447-.072%204.848-.079%203.2033-.007%203.5835.005%204.8495.0608%201.169.0508%201.8053.2445%202.228.408.5608.216.96.4754%201.3816.895.4217.4194.6816.8176.9005%201.3787.1653.4217.3617%201.056.4169%202.2263.0602%201.2655.0739%201.645.0796%204.848.0058%203.203-.0055%203.5834-.061%204.848-.051%201.17-.245%201.8055-.408%202.2294-.216.5604-.4763.96-.8954%201.3814-.419.4215-.8181.6811-1.3783.9-.4224.1649-1.0577.3617-2.2262.4174-1.2656.0595-1.6448.072-4.8493.079-3.2045.007-3.5825-.006-4.848-.0608M16.953%205.5864A1.44%201.44%200%201%200%2018.39%204.144a1.44%201.44%200%200%200-1.437%201.4424M5.8385%2012.012c.0067%203.4032%202.7706%206.1557%206.173%206.1493%203.4026-.0065%206.157-2.7701%206.1506-6.1733-.0065-3.4032-2.771-6.1565-6.174-6.1498-3.403.0067-6.156%202.771-6.1496%206.1738M8%2012.0077a4%204%200%201%201%204.008%203.9921A3.9996%203.9996%200%200%201%208%2012.0077%27%2F%3E%3C%2Fsvg%3E)></i> <span>Instagram</span> </a><li><a href="https://scholar.google.com/citations?user=sZIyj3IAAAAJ&hl=en" rel=" me" title="Google Scholar"> <i class=icon style=--icon:url(data:image/svg+xml,%3Csvg%20role%3D%27img%27%20viewBox%3D%270%200%2024%2024%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%3Ctitle%3EGoogle%20Scholar%3C%2Ftitle%3E%3Cpath%20d%3D%27M5.242%2013.769L0%209.5%2012%200l12%209.5-5.242%204.269C17.548%2011.249%2014.978%209.5%2012%209.5c-2.977%200-5.548%201.748-6.758%204.269zM12%2010a7%207%200%201%200%200%2014%207%207%200%200%200%200-14z%27%2F%3E%3C%2Fsvg%3E)></i> <span>Google Scholar</span> </a><li><a rel=" me" href=https://x.com/WilliamGuimont title=Twitter> <i class=icon style=--icon:url(data:image/svg+xml,%3Csvg%20role%3D%27img%27%20width%3D%27300%27%20height%3D%27300.251%27%20version%3D%271.1%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%3Cpath%20d%3D%27M178.57%20127.15%20290.27%200h-26.46l-97.03%20110.38L89.34%200H0l117.13%20166.93L0%20300.25h26.46l102.4-116.59%2081.8%20116.59h89.34M36.01%2019.54H76.66l187.13%20262.13h-40.66%27%2F%3E%3C%2Fsvg%3E)></i> <span>Twitter</span> </a><li><a rel=" me" href=https://mastodon.social/@willGuimont title=Mastodon> <i class=icon style=--icon:url(data:image/svg+xml,%3Csvg%20role%3D%27img%27%20viewBox%3D%270%200%2024%2024%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%3Ctitle%3EMastodon%3C%2Ftitle%3E%3Cpath%20d%3D%27M23.268%205.313c-.35-2.578-2.617-4.61-5.304-5.004C17.51.242%2015.792%200%2011.813%200h-.03c-3.98%200-4.835.242-5.288.309C3.882.692%201.496%202.518.917%205.127.64%206.412.61%207.837.661%209.143c.074%201.874.088%203.745.26%205.611.118%201.24.325%202.47.62%203.68.55%202.237%202.777%204.098%204.96%204.857%202.336.792%204.849.923%207.256.38.265-.061.527-.132.786-.213.585-.184%201.27-.39%201.774-.753a.057.057%200%200%200%20.023-.043v-1.809a.052.052%200%200%200-.02-.041.053.053%200%200%200-.046-.01%2020.282%2020.282%200%200%201-4.709.545c-2.73%200-3.463-1.284-3.674-1.818a5.593%205.593%200%200%201-.319-1.433.053.053%200%200%201%20.066-.054c1.517.363%203.072.546%204.632.546.376%200%20.75%200%201.125-.01%201.57-.044%203.224-.124%204.768-.422.038-.008.077-.015.11-.024%202.435-.464%204.753-1.92%204.989-5.604.008-.145.03-1.52.03-1.67.002-.512.167-3.63-.024-5.545zm-3.748%209.195h-2.561V8.29c0-1.309-.55-1.976-1.67-1.976-1.23%200-1.846.79-1.846%202.35v3.403h-2.546V8.663c0-1.56-.617-2.35-1.848-2.35-1.112%200-1.668.668-1.67%201.977v6.218H4.822V8.102c0-1.31.337-2.35%201.011-3.12.696-.77%201.608-1.164%202.74-1.164%201.311%200%202.302.5%202.962%201.498l.638%201.06.638-1.06c.66-.999%201.65-1.498%202.96-1.498%201.13%200%202.043.395%202.74%201.164.675.77%201.012%201.81%201.012%203.12z%27%2F%3E%3C%2Fsvg%3E)></i> <span>Mastodon</span> </a></ul></footer><span class=hidden id=copy-code-text>Copy Code</span><span class=hidden id=search-index>https://willguimont.com/search_index.en.json</span><span class=hidden id=more-matches-text>$MATCHES more matches</span><style>:root{--alert-note-text:"Note";--alert-tip-text:"Tip";--alert-important-text:"Important";--alert-warning-text:"Warning";--alert-caution-text:"Caution"}</style>